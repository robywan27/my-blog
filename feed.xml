<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://robywan27.github.io" rel="self" type="application/rss+xml"/><title>roby-wan $ elucubrations</title><link>https://robywan27.github.io</link><description>Personal blogging site about topics in the landscape of programming languages, software development, computer science</description><lastBuildDate>Wed, 13 Nov 2019 17:47:48 +0100</lastBuildDate><generator>clj-rss</generator><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</link><title>foldr vs foldl</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;Folding is one important topic in functional programming. It is a pattern exploiting the higher-order capability to compose functions, i.e. functions can be passed other functions arguments or can return a function. This pattern is used to employ common iterative operations over lists which reduce to a single result. This is in fact the algorithm behind the common library function &lt;em&gt;reduce&lt;/em&gt; implemented in most common programming languages nowadays. There are two variants of folding depending on the direction in which the computational process unfolds, so either right or left. This gives the names of &lt;strong&gt;foldr&lt;/strong&gt; and &lt;strong&gt;foldl&lt;/strong&gt;. The examples that follow will be written in Haskell for conciseness. I advice the book by Hutton &lt;sup class="footnote" id="_footnote_hutton"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; to have an introduction to these concepts or the  edX MOOC &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; which also provides plenty of exercises to consolidate the knowledge.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_foldr" class="sect0"&gt;foldr&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;sup class="footnoteref"&gt;[&lt;a class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;foldr f v [] = v
foldr f v (x : xs) = f x (foldr f v xs)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Even though it may look daunting at first sight, it becomes very clear and intuitive once you have grasped the meaning of it. This formula is written in recursive form, so the first line expresses the base case while the second line expresses the recursive case. The left-hand side of the formula is the application of the function &lt;code&gt;foldr&lt;/code&gt; on parameters:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;, the name of the function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;v&lt;/code&gt; , the initial value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; is the empty list; the base case means that at this point of the computation there are no more elements in the list to consider&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(x : xs)&lt;/code&gt;, which is the Haskell notation to express a list composed of head (first element) &lt;code&gt;x&lt;/code&gt; and tail (all elements from second to last) &lt;code&gt;xs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now for the interesting part, the right-hand side of the formula. In the base case, the function simply returns the initial value. Easy. In the recursive case, function &lt;code&gt;f&lt;/code&gt; is applied to the first element of the list &lt;code&gt;x&lt;/code&gt;. After that, the &lt;code&gt;foldr&lt;/code&gt; function is called recursively on the remaining elements of the list.
Now it is clear that the computational process of &lt;code&gt;foldr&lt;/code&gt; has a recursive shape.
Let&amp;#8217;s make an example to illustrate what previously said.
Turns out that the common higher-order pattern &lt;code&gt;map&lt;/code&gt; can be rewritten in terms of &lt;code&gt;foldr&lt;/code&gt;: &lt;code&gt;mapR f = foldr (\ x xs &amp;#8594; f x : xs) []&lt;/code&gt;.
Here the application of function &lt;code&gt;f&lt;/code&gt; over the list is defined in terms of an anonymous function (lambda function) taking two parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;xs&lt;/code&gt;. The empty list &lt;code&gt;[]&lt;/code&gt; is  the initial value (&lt;code&gt;v&lt;/code&gt; in the formula above). &lt;code&gt;x&lt;/code&gt; represents the first item in the list starting from the end of the list, while &lt;code&gt;xs&lt;/code&gt; represents the accumulator. So the lambda function returns a list composed of the function application on element &lt;code&gt;x&lt;/code&gt; concatenated with the accumulator &lt;code&gt;xs&lt;/code&gt;. To properly understand how the computation unfolds, I find it more intuitive to reason backwards, starting from the last element moving backwards to the first; the accumulator is then compounded starting with the empty list on the right and prepending the elements of the list one by one starting from the last element. For example applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;[1,2,3]&lt;/code&gt; taking function &lt;code&gt;(*2)&lt;/code&gt; gives the list &lt;code&gt;[2,4,6]&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;map (*2) [1,2,3]
((*2) 1) : ((*2) 2) : ((*2) 3) : []
2 : 4 :  6 : [] = [2,4,6]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id="_foldl" class="sect0"&gt;foldl&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;sup class="footnoteref"&gt;[&lt;a class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;foldl f v [] = v
foldl f v (x : xs) = foldl f (f v x) xs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This function shares many similarities with the one expressed above for &lt;code&gt;foldr&lt;/code&gt;. The difference lies in the right-hand side of the recursive case formula. &lt;code&gt;foldl&lt;/code&gt; is called recursively, and it is given the following arguments:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;, the function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(f v x)&lt;/code&gt;, is the accumulator, which is given by the application of &lt;code&gt;f&lt;/code&gt; on the previous value of the accumulator &lt;code&gt;v&lt;/code&gt; and the first element of the list &lt;code&gt;x&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs&lt;/code&gt;, the remaining elements of the list starting from the second one&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear that &lt;code&gt;foldl&lt;/code&gt; follows an iterative shape instead, as the algorithm starts by applying the function to the base case and the first element of the list; this is the new accumulator. Then the function is applied to the next element and the accumulator, which results in a new accumulator. This process continues until the end of the list is reached. Note that I have not said that the accumulator assumes a new value at each step, because the evaluation is done after the unwrapping of the list starting from right to left, which gives the name to the pattern.
For symmetry, I am going to express the function &lt;code&gt;map&lt;/code&gt; using &lt;code&gt;foldl&lt;/code&gt;:
&lt;code&gt;mapL f = foldl (\ xs x &amp;#8594; xs ++ [f x]) []&lt;/code&gt;.
The lambda function takes two parameters: &lt;code&gt;xs&lt;/code&gt; is the accumulator, while &lt;code&gt;x&lt;/code&gt; is the first element of the list. A list is returned, composed of the application of &lt;code&gt;f&lt;/code&gt; on &lt;code&gt;x&lt;/code&gt;, to which is prepended the accumulator &lt;code&gt;xs&lt;/code&gt;. Note that the accumulator is the initial value &lt;code&gt;[]&lt;/code&gt;. So the computation unfolds from left to right, and once the end of the list is reached, it starts folding back from right to left, hence the name. Applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;[1,2,3]&lt;/code&gt; taking function &lt;code&gt;(*2)&lt;/code&gt; gives the list &lt;code&gt;[2,4,6]&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;map (*2) [1,2,3]
(([] ++ [(*2) 1]) ++ [(*2) 2]) ++ [(*2) 3]
[] ++ [2] ++ [4] ++ [6] = [2,4,6]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html" class="bare"&gt;http://www.cs.nott.ac.uk/~pszgmh/pih.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" class="bare"&gt;https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</link><title>Expressions vs statements</title><description>&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;Statements&lt;/strong&gt; are standalone units of execution which do not return any value. As such, it is clear that they are used to perform side effects in a program.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_functional_vs_imperative"&gt;Functional vs imperative&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To get an overview of the different paradigms you can refer to article &amp;lt;link to prog paradigms&amp;gt;.
Given the definitions above, it is clear that &lt;strong&gt;expressions&lt;/strong&gt; constitute the building blocks of the &lt;strong&gt;functional paradigm&lt;/strong&gt;, since everything should be always evaluated to give a value, and regardless of the time of invocation, given the same inputs should return same output values out of the expression. Statements, on the other hand, as said previously, are meant to provide side effects to the program, so it is clear that they can&amp;#8217;t exist in purely functional programs.
On the other hand, &lt;strong&gt;statements&lt;/strong&gt; are fundamental blocks of the &lt;strong&gt;imperative&lt;/strong&gt; style (together with expressions) as they are used to alter the control flow of the program through constructs such as conditionals, loops, procedures.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_examples"&gt;Examples&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here follow a few examples to illustrate the differences outlined above.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_if_conditionals"&gt;If conditionals&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Some languages provide conditionals as expressions while others as statements; it is usually the case that languages that employ statements also provide an equivalent expression form (the ternary operator).
If the conditional is an &lt;strong&gt;expression&lt;/strong&gt;, it is evaluated to value, which means that it can be for example assigned to a variable or passed as a function argument; basically, it can be treated as any other value. In standard ML one can write for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;val acidity = if ph &amp;lt; 7 then "ACID" else if ph = 7 then "NEUTRAL" else "BASE"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear that, being an expression, the conditional is required by the language to provide a value no matter what, thus all possible cases should be considered and a value should be returned for each. In this example the else branches are not optional, because if the ph level is greater or equals to 7, there must be some other value you return.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If the conditional is a &lt;strong&gt;statement&lt;/strong&gt;, it doesn&amp;#8217;t return a value, so for example it cannot be assigned to a variable, but it is a sort of logical block containing instructions with side effects. In Python you could write an if statement like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;acidity = ... # could be any value
...
if ph &amp;lt; 7:
	acidity = "ACID"
elif ph == 7:
	acidity = "NEUTRAL"
else:
	acidity = "BASE"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This snippet shows that, no matter which branch is taken, the statement mutates the value of the variable &lt;code&gt;acidity&lt;/code&gt;. Note that it would be illegal syntax to assign this block to the variable &lt;code&gt;acidity&lt;/code&gt;. Finally, the language does not enforce you to provide a value for all the possible values of &lt;code&gt;ph&lt;/code&gt;, you could in fact only define the first if branch and ignore the other cases.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_loops"&gt;Loops&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imperative languages provide different constructs to loop over series of values or data structures (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &amp;#8230;&amp;#8203;) which produce side effects. Functional languages instead do not provide a loop construct, but rely on the mechanism of recursion over data structures to implement it, since a value is returned out of it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_languages_mixing_both_paradigms"&gt;Languages mixing both paradigms&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is now clear how languages that mix both the functional and imperative (e.g. object-oriented) styles make you define a certain construct either as an expression or as a statement respectively. For example, in Kotlin the body of a function can be defined as:
- functional style: &lt;code&gt;fun f() = when {&amp;#8230;&amp;#8203;}&lt;/code&gt; the body is an expression and when it is evaluated to produce a value, this is assigned to the function.
- oo style:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;fun f(ch: Char) {
	ch = ch + 1
	print(ch)
	return ch
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;the body is a statement composed of a sequence of instructions producing side effects.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_wrap_up"&gt;Wrap-up&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We have seen that while expressions are evaluated to return a value, statements do not return any value, performing instead side effects. As such, programs written in the imperative style are constituted by both expressions and statements which implement some logic altering the state of the program (e.g. conditions, looping). The functional paradigm instead mandates the exclusive usage of expressions since by definition side effects are not admitted.
The &lt;strong&gt;advantages&lt;/strong&gt; of using &lt;strong&gt;expressions over statements&lt;/strong&gt; is first of all that the program is contained from the side effects which would be introduced were you to use statements. Another advantage is that all constructs in the program are always evaluated to a value; as such, they can be passed around in the program as you would with simple values such as primitives or simple expressions. This favours composition, since the program itself is an expression made out of other expressions which produce a value. This means that the program can be passed around, returned or composed, allowing for further flexibility.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</link><title>Function closures</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The topic of this post is function closures. Closure refers to the context that is passed to a function when it is defined. Basically, the state of the variables that are in the lexical scope when the function is defined is captured and retained in the function. Thus, when the function is subsequently invoked, the variables referenced by the function retain the value they possessed in the lexical scope of the function when it was defined, even though the current scope may be completely different! In Javascript we could write for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;let x = 4;
let f = y =&amp;gt; y + x;
...
x = 7;
f(2); // this will return the value 6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As visible from this simple example, the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope of the function &lt;code&gt;f&lt;/code&gt; at the moment of its declaration and is bound to the value &lt;code&gt;4&lt;/code&gt;. At a later point in the program the value of the variable &lt;code&gt;x&lt;/code&gt; is changed to &lt;code&gt;7&lt;/code&gt;, and the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope when the function is invoked in the last line. However, the result of the function application is &lt;code&gt;6&lt;/code&gt; instead of &lt;code&gt;9&lt;/code&gt;. The reason for this is that function &lt;code&gt;f&lt;/code&gt; had a closure over &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; was defined, so no matter what value &lt;code&gt;x&lt;/code&gt; may have in the future, it is still bound to &lt;code&gt;4&lt;/code&gt; any time &lt;code&gt;f&lt;/code&gt; is invoked. The same would be valid even if &lt;code&gt;x&lt;/code&gt; would not be in the current scope at the moment function &lt;code&gt;f&lt;/code&gt; is invoked.
This simple example illustrated an important feature of closures: functions can store the information present in the lexical scope where they are defined. The implications of this are huge, and many idioms and patterns have found foundation from this concept.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_currying" class="sect0"&gt;Currying&lt;/h1&gt;

&lt;h1 id="_memoization" class="sect0"&gt;Memoization&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The memoization technique is useful when you want to cache the result of some expensive computation. It basically consists in storing a local reference inside a function to a variable defined outside the function; its value is going to be used in some expensive computation. The first time the function is invoked, you may check whether the variable is defined (you may also use a boolean flag for the purpose of checking), and since it is not, the function body is evaluated to produce the result of the computation which is going to be stored in a local variable. So, any subsequent times the function is called, the function will limit itself to return the result of the computation instead of recomputing it every time.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_library_wrapping" class="sect0"&gt;Library wrapping&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another example of pattern commonly employed in Javascript is library wrapping, also known with the name of revealing module pattern, and it is used to create a module abstraction in an environment were every element would have public visibility otherwise.&lt;/p&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</link><title>Programming paradigms explained</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The topic of this post concerns something fundamental in the matter of programming: programming paradigms. Note that, while there exist other paradigms other than the ones considered here, these will not be treated as they are out of the scope of this post.
We will first consider the two main approaches overarching all the other paradigms: imperative and declarative. I also advice to have a look at the definitions provided in the very first chapter of &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; for a very good explanation of the difference between the two.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_imperative" class="sect0"&gt;Imperative&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imperative is concerned with the &lt;strong&gt;how-to&lt;/strong&gt; knowledge of an algorithm, i.e. it details the sequence of steps or instructions necessary to accomplish a certain algorithm. An analogy to visualise this could be for example the following sequence of instructions to go from point A to point B:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;move two cells to the right
move one cell to the top
move five cells to the right
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id="_declarative" class="sect0"&gt;Declarative&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Declarative deals instead with the &lt;strong&gt;what-is&lt;/strong&gt; knowledge, thus it provides a definition but does not specify the steps for a certain algorithm. This approach is more proper to mathematics, mathematical formulae are a very good example of declarative knowledge. For instance, to calculate the hypotenuse of a right triangle you could use the Pythagorean theorem &lt;code&gt;c^2 = a^2 + b^2"&lt;/code&gt;. Note that it does not give you a list of instructions of how to calculate the hypotenuse, just a definition.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_main_paradigms" class="sect0"&gt;Main paradigms&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now we will consider the most common paradigms.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_procedural" class="sect0"&gt;Procedural&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is the paradigm used to indicate those programs in which the code is organised into logical units called procedures. Contrarily to functions, procedures do not return any value, but act simply as groupings of instructions. This style of programming is the first to have been employed and dates back to Fortran. The main merits of this paradigm is that of introducing modularity and scoping into programs. Note that this style is purely imperative.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_object_oriented" class="sect0"&gt;Object-oriented&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Object-oriented is perhaps the most well-known paradigm since it has been since the late '80s-'90s the de-facto standard in the industry. This style differs from the procedural in that it introduces several concepts such as class, interface, inheritance, polymorphism which add layers of abstraction to the program and model the reality with entities interacting between each others. Their interactions cause mutations in the state of the objects, which can lead to untameable complexity if not properly managed and kept under control with the proper amount of testing. A complete treaty of this paradigm is out of the scope of this post, as there are loads of good resources out there explaining exhaustively OO concepts &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote."&gt;3&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote."&gt;4&lt;/a&gt;]&lt;/sup&gt;. This style of programming is imperative.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_functional" class="sect0"&gt;Functional&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;According to this paradigm, programs should be composed of pure functions and immutable data structures. Pure functions are functions which do not cause any side effect, i.e. they do not change the state of the program. Immutable data structures indicate that any data structure in the program is not mutated; in order to perform computations on these structures, copies are made and acted on. Another characteristic of the functional style is that functions are first-class citizens, i.e. they can be treated as any other value, thus assigned to variables, passed around in functions either as arguments or return values, etc. This makes the program more declarative since you define the specification of a computational process through pure functions and their composition instead of defining the sequence of instructions which implements the required computational process.
Note that for real applications a purely functional approach by itself is pretty much useless, as the program would just act as a box computing things but without any connection with the outer world. For this reason, even pure functional languages such as Haskell provide mechanisms to deal with state mutation or side effects. This comes to the cost of losing the declarative quality typical of functional programs.
An example of this in Haskell is the &lt;code&gt;do&lt;/code&gt; block for monads, useful to deal with side effects:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;do
	putStrLn "hello"
	putStrLn "world"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another example is the &lt;code&gt;begin&lt;/code&gt; block in Scheme or Racket to express sequences of instructions:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(begin
  (printf "hello")
  (+ 1 2))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_3"&gt;
&lt;a href="#_footnoteref_3"&gt;3&lt;/a&gt;. &lt;a href="https://www.goodreads.com/book/show/4845.Code_Complete" class="bare"&gt;https://www.goodreads.com/book/show/4845.Code_Complete&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_4"&gt;
&lt;a href="#_footnoteref_4"&gt;4&lt;/a&gt;. &lt;a href="http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html" class="bare"&gt;http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</link><title>Static vs dynamic type checking</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The type system is one of the fundamental elements which make up a programming language. There are two main categories under which most languages fall into: static and dynamic type checking. This taxonomy is orthogonal to that of programming paradigms such as object-oriented and functional.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_static_type_checking" class="sect0"&gt;Static type checking&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A strong type checking system mandates that every value in the program belong to one supported type in the program. If the compiler cannot infer the type of any given value, it will throw an error. For this reason, it is possible for statically-typed languages to detect type errors at compile time, which provides benefits later when the program is run. The fact that the program passes the compilation phase does not imply that the program is correct though, as there may be other kinds of errors in it. An interesting topic related to static type checking is type inference, which is employed by SML and its derived languages (link to article about type inference and Hindley-Milner).&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_dynamic_type_checking" class="sect0"&gt;Dynamic type checking&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Dynamically-typed languages skip the type checking phase and the program is executed straight away. It is usually the case that languages employing this type checking are not compiled but rather interpreted, such as Ruby, Javascript, Python, Scheme (the reality can be more complex than written here, but a detailed treaty is out of scope).  This means that the class of errors which may have likely been detected with static type checking will go undetected until the running program incurs in them and crashes or even worse it executes wrongly. Although dynamically-typed languages give up program safety, they gain in flexibility; in fact, they allow the programmer to define heterogeneous data structures and abstractions which would otherwise be clumsy if not possible in a statically-typed language. For example, it is possible in Scheme to define lists of any element regardless of the type. A valid list can be &lt;code&gt;(1 "2" #t)&lt;/code&gt;. This is not possible in Haskell for example, where each element of a list must conform to the specified type of the list:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;multiplyByTwo :: [Int] -&amp;gt; [Int]
multiplyByTwo xs = map (*2) xs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;which when executed at the command line gives&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt; multiplyByTwo [1, 2, 3, 4]
[2, 4, 6, 8]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;One misconception to be beware of is that dynamic type does not mean that values do not have types, they are indeed typed, just their type is inferred while the program is running rather than by the compiler.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_strong_vs_weak_type" class="sect0"&gt;Strong vs weak type&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;An honourable mention is worth giving to the strong vs weak type classification, since it is often wrongly used interchangeably instead of static and dynamic type checking. Actually, there is not a definitive definition of strong and weak type. Most languages, even dynamically-typed ones, are strongly typed. Weakly-typed languages are those languages which perform some kind of implicit type conversion. C and C++ are the most well-known languages which can be defined weakly-typed.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_overview_of_some_popular_languages" class="sect0"&gt;Overview of some popular languages&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As a closing point I will provide an overview of some popular languages in relation to their type system and programming paradigm.
The following table provides a rough classification of some popular languages:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-topbot grid-all" style="width: 90%;"&gt;
&lt;caption class="title"&gt;Table 1. Table Classification of some popular programming languages wrt type checking and paradigm&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style="width: 33.3333%;"&gt;
&lt;col style="width: 33.3333%;"&gt;
&lt;col style="width: 33.3334%;"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-right valign-top"&gt;&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;dynamically-typed&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;statically-typed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-right valign-top"&gt;&lt;p class="tableblock"&gt;&lt;strong&gt;object-oriented&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Ruby&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Java, C++&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-right valign-top"&gt;&lt;p class="tableblock"&gt;&lt;strong&gt;functional&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Scheme, Clojure, Elixir&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;SML, Haskell&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that it is usually not entirely correct that a language follows exclusively one single paradigm as most popular languages are multi-paradigm. Nonetheless there is usually one paradigm which is primary to a given language. Some other languages position in the middle and allow both styles interchangeably, such as Scala and Kotlin. Some languages have not been included as their classification would be ambiguous. Python is weakly-typed and supports both paradigms, even though it is more apt to either a procedural or object-oriented style. Javascript is weakly-typed and draws a lot from the functional approach, even though it does support some kind of object-oriented form.&lt;/p&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item></channel></rss>