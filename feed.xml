<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://robywan27.github.io" rel="self" type="application/rss+xml"/><title>Elucubrations</title><link>https://robywan27.github.io</link><description>Personal blogging site about topics in the landscape of programming languages, software development, computer science</description><lastBuildDate>Mon, 11 Nov 2019 17:31:41 +0100</lastBuildDate><generator>clj-rss</generator><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</link><title>Programming paradigms explained</title><description>&lt;p&gt;The topic of this post concerns something fundamental in the matter of programming: programming paradigms. Note that, while there exist other paradigms other than the ones considered here, these will not be treated as they are out of the scope of this post. We will first consider the two main approaches overarching all the other paradigms: imperative and declarative. I also advice to have a look at the definitions provided in the very first chapter of &lt;em&gt;Structure and Interpretation of Computer Programs&lt;/em&gt; &lt;a href='#fn-1' id='fnref1'&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; for a very good explanation of the difference between the two.&lt;/p&gt;&lt;h1 id="imperative"&gt;Imperative&lt;/h1&gt;&lt;p&gt;Imperative is concerned with the &lt;em&gt;how-to&lt;/em&gt; knowledge of an algorithm, i.e. it details the sequence of steps or instructions necessary to accomplish a certain algorithm. An analogy to visualise this could be for example the following sequence of instructions to go from point A to point B:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;move two cells to the right
move one cell to the top
move five cells to the right
...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id="declarative"&gt;Declarative&lt;/h1&gt;&lt;p&gt;Declarative deals instead with the &lt;em&gt;what-is&lt;/em&gt; knowledge, thus it provides a definition but does not specify the steps for a certain algorithm. This approach is more proper to mathematics, mathematical formulae are a very good example of declarative knowledge. For instance, to calculate the hypotenuse of a right triangle you could use the Pythagorean theorem &lt;code&gt;c&amp;#94;2 = a&amp;#94;2 + b&amp;#94;2&amp;quot;&lt;/code&gt;. Note that it does not give you a list of instructions of how to calculate the hypotenuse, just a definition.&lt;/p&gt;&lt;h1 id="main&amp;#95;paradigms"&gt;Main paradigms&lt;/h1&gt;&lt;p&gt;Now we will consider the most common paradigms.&lt;/p&gt;&lt;h1 id="procedural"&gt;Procedural&lt;/h1&gt;&lt;p&gt;This is the paradigm used to indicate those programs in which the code is organised into logical units called procedures. Contrarily to functions, procedures do not return any value, but act simply as groupings of instructions. This style of programming is the first to have been employed and dates back to Fortran. The main merits of this paradigm is that of introducing modularity and scoping into programs. Note that this style is purely imperative.&lt;/p&gt;&lt;h1 id="object-oriented"&gt;Object-oriented&lt;/h1&gt;&lt;p&gt;Object-oriented is perhaps the most well-known paradigm since it has been since the late '80s-'90s the de-facto standard in the industry. This style differs from the procedural in that it introduces several concepts such as class, interface, inheritance, polymorphism which add layers of abstraction to the program and model the reality with entities interacting between each others. Their interactions cause mutations in the state of the objects, which can lead to untameable complexity if not properly managed and kept under control with the proper amount of testing. A complete treaty of this paradigm is out of the scope of this post, as there are loads of good resources out there explaining exhaustively OO concepts &lt;a href='#fn-2' id='fnref2'&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.  This style of programming is imperative.&lt;/p&gt;&lt;h1 id="functional"&gt;Functional&lt;/h1&gt;&lt;p&gt;According to this paradigm, programs should be composed of pure functions and immutable data structures. Pure functions are functions which do not cause any side effect, i.e. they do not change the state of the program. Immutable data structures indicate that any data structure in the program is not mutated; in order to perform computations on these structures, copies are made and acted on. Another characteristic of the functional style is that functions are first-class citizens, i.e. they can be treated as any other value, thus assigned to variables, passed around in functions either as arguments or return values, etc. This makes the program more declarative since you define the specification of a computational process through pure functions and their composition instead of defining the sequence of instructions which implements the required computational process. Note that for real applications a purely functional approach by itself is pretty much useless, as the program would just act as a box computing things but without any connection with the outer world. For this reason, even pure functional languages such as Haskell provide mechanisms to deal with state mutation or side effects. This comes to the cost of losing the declarative quality typical of functional programs. An example of this in Haskell is the &lt;code&gt;do&lt;/code&gt; block for monads, useful to deal with side effects:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;do
	putStrLn &amp;quot;hello&amp;quot;
	putStrLn &amp;quot;world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another example is the &lt;code&gt;begin&lt;/code&gt; block in Scheme or Racket to express sequences of instructions:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;#40;begin
  &amp;#40;printf &amp;quot;hello&amp;quot;&amp;#41;
  &amp;#40;+ 1 2&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href='#fn-3' id='fnref3'&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; &lt;a href='https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html'&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;  &lt;a href='https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/'&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/&lt;/a&gt; &lt;a href='#fn-4' id='fnref4'&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; &lt;a href='https://www.goodreads.com/book/show/4845.Code_Complete'&gt;https://www.goodreads.com/book/show/4845.Code_Complete&lt;/a&gt; &lt;a href='http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html'&gt;http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html&lt;/a&gt; &lt;ol class='footnotes'&gt;&lt;li id='fn-1'&gt;&lt;a href='#fnref1'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-2'&gt;&lt;a href='#fnref2'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-3'&gt;&lt;a href='#fnref3'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-4'&gt;&lt;a href='#fnref4'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</link><title>Function closures</title><description>&lt;p&gt;The topic of this post is function closures. Closure refers to the context that is passed to a function when it is defined. Basically, the state of the variables that are in the lexical scope when the function is defined is captured and retained in the function. Thus, when the function is subsequently invoked, the variables referenced by the function retain the value they possessed in the lexical scope of the function when it was defined, even though the current scope may be completely different! In Javascript we could write for example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;let x = 4;
let f = y =&amp;gt; y + x;
...
x = 7;
f&amp;#40;2&amp;#41;; // this will return the value 6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As visible from this simple example, the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope of the function &lt;code&gt;f&lt;/code&gt; at the moment of its declaration and is bound to the value &lt;code&gt;4&lt;/code&gt;. At a later point in the program the value of the variable &lt;code&gt;x&lt;/code&gt; is changed to &lt;code&gt;7&lt;/code&gt;, and the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope when the function is invoked in the last line. However, the result of the function application is &lt;code&gt;6&lt;/code&gt; instead of &lt;code&gt;9&lt;/code&gt;. The reason for this is that function &lt;code&gt;f&lt;/code&gt; had a closure over &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; was defined, so no matter what value &lt;code&gt;x&lt;/code&gt; may have in the future, it is still bound to &lt;code&gt;4&lt;/code&gt; any time &lt;code&gt;f&lt;/code&gt; is invoked. The same would be valid even if &lt;code&gt;x&lt;/code&gt; would not be in the current scope at the moment function &lt;code&gt;f&lt;/code&gt; is invoked. This simple example illustrated an important feature of closures: functions can store the information present in the lexical scope where they are defined. The implications of this are huge, and many idioms and patterns have found foundation from this concept.&lt;/p&gt;&lt;h1 id="currying"&gt;Currying&lt;/h1&gt;&lt;h1 id="memoization"&gt;Memoization&lt;/h1&gt;&lt;p&gt;The memoization technique is useful when you want to cache the result of some expensive computation. It basically consists in storing a local reference inside a function to a variable defined outside the function; its value is going to be used in some expensive computation. The first time the function is invoked, you may check whether the variable is defined (you may also use a boolean flag for the purpose of checking), and since it is not, the function body is evaluated to produce the result of the computation which is going to be stored in a local variable. So, any subsequent times the function is called, the function will limit itself to return the result of the computation instead of recomputing it every time.&lt;/p&gt;&lt;h1 id="library&amp;#95;wrapping"&gt;Library wrapping&lt;/h1&gt;&lt;p&gt;Another example of pattern commonly employed in Javascript is library wrapping, also known with the name of revealing module pattern, and it is used to create a module abstraction in an environment were every element would have public visibility otherwise.&lt;/p&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</link><title>Static vs dynamic type checking</title><description>&lt;p&gt;The type system is one of the fundamental elements which make up a programming language. There are two main categories under which most languages fall into: static and dynamic type checking. This taxonomy is orthogonal to that of programming paradigms such as object-oriented and functional. &lt;/p&gt;&lt;h1 id="static&amp;#95;type&amp;#95;checking"&gt;Static type checking&lt;/h1&gt;&lt;p&gt;A strong type checking system mandates that every value in the program belong to one supported type in the program. If the compiler cannot infer the type of any given value, it will throw an error. For this reason, it is possible for statically-typed languages to detect type errors at compile time, which provides benefits later when the program is run. The fact that the program passes the compilation phase does not imply that the program is correct though, as there may be other kinds of errors in it. An interesting topic related to static type checking is type inference, which is employed by SML and its derived languages (link to article about type inference and Hindley-Milner).&lt;/p&gt;&lt;h1 id="dynamic&amp;#95;type&amp;#95;checking"&gt;Dynamic type checking&lt;/h1&gt;&lt;p&gt;Dynamically-typed languages skip the type checking phase and the program is executed straight away. It is usually the case that languages employing this type checking are not compiled but rather interpreted, such as Ruby, Javascript, Python, Scheme (the reality can be more complex than written here, but a detailed treaty is out of scope).  This means that the class of errors which may have likely been detected with static type checking will go undetected until the running program incurs in them and crashes or even worse it executes wrongly. Although dynamically-typed languages give up program safety, they gain in flexibility; in fact, they allow the programmer to define heterogeneous data structures and abstractions which would otherwise be clumsy if not possible in a statically-typed language. For example, it is possible in Scheme to define lists of any element regardless of the type. A valid list can be &lt;code&gt;&amp;#40;1 &amp;quot;2&amp;quot; #t&amp;#41;&lt;/code&gt;. This is not possible in Haskell for example, where each element of a list must conform to the specified type of the list:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;multiplyByTwo :: &amp;#91;Int&amp;#93; -&amp;gt; &amp;#91;Int&amp;#93;
multiplyByTwo xs = map &amp;#40;&amp;#42;2&amp;#41; xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;which when executed at the command line gives&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt; multiplyByTwo &amp;#91;1, 2, 3, 4&amp;#93;
&amp;#91;2, 4, 6, 8&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;One misconception to be beware of is that dynamic type does not mean that values do not have types, they are indeed typed, just their type is inferred while the program is running rather than by the compiler.&lt;/p&gt;&lt;h1 id="strong&amp;#95;vs&amp;#95;weak&amp;#95;type"&gt;Strong vs weak type&lt;/h1&gt;&lt;p&gt;An honourable mention is worth giving to the strong vs weak type classification, since it is often wrongly used interchangeably instead of static and dynamic type checking. Actually, there is not a definitive definition of strong and weak type. Most languages, even dynamically-typed ones, are strongly typed. Weakly-typed languages are those languages which perform some kind of implicit type conversion. C and C++ are the most well-known languages which can be defined weakly-typed.&lt;/p&gt;&lt;h1 id="overview&amp;#95;of&amp;#95;some&amp;#95;popular&amp;#95;languages"&gt;Overview of some popular languages&lt;/h1&gt;&lt;p&gt;As a closing point I will provide an overview of some popular languages in relation to their type system and programming paradigm. The following table provides a rough classification of some popular languages:&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;||object-oriented|Ruby            |Java, C++            ||functional          |Scheme/Racket, Clojure, Erlang/Elixir            |SML, Haskell            |Note that it is usually not entirely correct that a language follows exclusively one single paradigm as most popular languages are multi-paradigm. Nonetheless there is usually one paradigm which is primary to a given language. Some other languages position in the middle and allow both styles interchangeably, such as Scala and Kotlin. Some languages have not been included as their classification would be ambiguous. Python is weakly-typed and supports both paradigms, even though it is more apt to either a procedural or object-oriented style. Javascript is weakly-typed and draws a lot from the functional approach, even though it does support some kind of object-oriented form. </description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</link><title>Foldr vs foldl</title><description>&lt;p&gt;Folding is one important topic in functional programming. It is a pattern exploiting the higher-order capability to compose functions, i.e. functions can be passed other functions arguments or can return a function. This pattern is used to employ common iterative operations over lists which reduce to a single result. This is in fact the algorithm behind the common library function &lt;em&gt;reduce&lt;/em&gt; implemented in most common programming languages nowadays. There are two variants of folding depending on the direction in which the computational process unfolds, so either right or left. This gives the names of &lt;em&gt;foldr&lt;/em&gt; and &lt;em&gt;foldl&lt;/em&gt;. The examples that follow will be written in Haskell for conciseness. I advice the book by Hutton &lt;a href='#fn-1' id='fnref1'&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; to have an introduction to these concepts or the  edX MOOC &lt;a href='#fn-2' id='fnref2'&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; which also provides plenty of exercises to consolidate the knowledge.&lt;/p&gt;&lt;h1 id="foldr"&gt;Foldr&lt;/h1&gt;&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;a href='#fn-3' id='fnref3'&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;foldr f v &amp;#91;&amp;#93; = v
foldr f v &amp;#40;x : xs&amp;#41; = f x &amp;#40;foldr f v xs&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Even though it may look daunting at first sight, it becomes very clear and intuitive once you have grasped the meaning of it. This formula is written in recursive form, so the first line expresses the base case while the second line expresses the recursive case. The left-hand side of the formula is the application of the function &lt;code&gt;foldr&lt;/code&gt; on parameters&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;f&lt;/code&gt;, the name of the function&lt;ul&gt;&lt;li&gt;&lt;code&gt;v&lt;/code&gt; , the initial value&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#91;&amp;#93;&lt;/code&gt; is the empty list; the base case means that at this point of the computation there are no more elements in the list to consider&lt;/li&gt;&lt;li&gt;&lt;code&gt;&amp;#40;x : xs&amp;#41;&lt;/code&gt;, which is the Haskell notation to express a list composed of head (first element) &lt;code&gt;x&lt;/code&gt; and tail (all elements from second to last) &lt;code&gt;xs&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Now for the interesting part, the right-hand side of the formula. In the base case, the function simply returns the initial value. Easy. In the recursive case, function &lt;code&gt;f&lt;/code&gt; is applied to the first element of the list &lt;code&gt;x&lt;/code&gt;. After that, the &lt;code&gt;foldr&lt;/code&gt; function is called recursively on the remaining elements of the list. Now it is clear that the computational process of &lt;code&gt;foldr&lt;/code&gt; has a recursive shape. Let's make an example to illustrate what previously said. Turns out that the common higher-order pattern &lt;code&gt;map&lt;/code&gt; can be rewritten in terms of &lt;code&gt;foldr&lt;/code&gt;: &lt;code&gt;mapR f = foldr &amp;#40;\ x xs -&amp;gt; f x : xs&amp;#41; &amp;#91;&amp;#93;&lt;/code&gt;. Here the application of function &lt;code&gt;f&lt;/code&gt; over the list is defined in terms of an anonymous function (lambda function) taking two parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;xs&lt;/code&gt;. The empty list &lt;code&gt;&amp;#91;&amp;#93;&lt;/code&gt; is  the initial value (&lt;code&gt;v&lt;/code&gt; in the formula above). &lt;code&gt;x&lt;/code&gt; represents the first item in the list starting from the end of the list, while &lt;code&gt;xs&lt;/code&gt; represents the accumulator. So the lambda function returns a list composed of the function application on element &lt;code&gt;x&lt;/code&gt; concatenated with the accumulator &lt;code&gt;xs&lt;/code&gt;. To properly understand how the computation unfolds, I find it more intuitive to reason backwards, starting from the last element moving backwards to the first; the accumulator is then compounded starting with the empty list on the right and prepending the elements of the list one by one starting from the last element. For example applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;&amp;#91;1,2,3&amp;#93;&lt;/code&gt; taking function &lt;code&gt;&amp;#40;&amp;#42;2&amp;#41;&lt;/code&gt; gives the list &lt;code&gt;&amp;#91;2,4,6&amp;#93;&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;map &amp;#40;&amp;#42;2&amp;#41; &amp;#91;1,2,3&amp;#93;
&amp;#40;&amp;#40;&amp;#42;2&amp;#41; 1&amp;#41; : &amp;#40;&amp;#40;&amp;#42;2&amp;#41; 2&amp;#41; : &amp;#40;&amp;#40;&amp;#42;2&amp;#41; 3&amp;#41; : &amp;#91;&amp;#93;
2 : 4 :  6 : &amp;#91;&amp;#93; = &amp;#91;2,4,6&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id="foldl"&gt;Foldl&lt;/h1&gt;&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;a href='#fn-4' id='fnref4'&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;foldl f v &amp;#91;&amp;#93; = v
foldl f v &amp;#40;x : xs&amp;#41; = foldl f &amp;#40;f v x&amp;#41; xs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This function shares many similarities with the one expressed above for &lt;code&gt;foldr&lt;/code&gt;. The difference lies in the right-hand side of the recursive case formula. &lt;code&gt;foldl&lt;/code&gt; is called recursively, and it is given the following arguments:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;f&lt;/code&gt;, the function&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;#40;f v x&amp;#41;&lt;/code&gt;, is the accumulator, which is given by the application of &lt;code&gt;f&lt;/code&gt; on the previous value of the accumulator &lt;code&gt;v&lt;/code&gt; and the first element of the list &lt;code&gt;x&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;xs&lt;/code&gt;, the remaining elements of the list starting from the second one&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;It is clear that &lt;code&gt;foldl&lt;/code&gt; follows an iterative shape instead, as the algorithm starts by applying the function to the base case and the first element of the list; this is the new accumulator. Then the function is applied to the next element and the accumulator, which results in a new accumulator. This process continues until the end of the list is reached. Note that I have not said that the accumulator assumes a new value at each step, because the evaluation is done after the unwrapping of the list starting from right to left, which gives the name to the pattern. For symmetry, I am going to express the function &lt;code&gt;map&lt;/code&gt; using &lt;code&gt;foldl&lt;/code&gt;: &lt;code&gt;mapL f = foldl &amp;#40;\ xs x -&amp;gt; xs ++ &amp;#91;f x&amp;#93;&amp;#41; &amp;#91;&amp;#93;&lt;/code&gt;. The lambda function takes two parameters: &lt;code&gt;xs&lt;/code&gt; is the accumulator, while &lt;code&gt;x&lt;/code&gt; is the first element of the list. A list is returned, composed of the application of &lt;code&gt;f&lt;/code&gt; on &lt;code&gt;x&lt;/code&gt;, to which is prepended the accumulator &lt;code&gt;xs&lt;/code&gt;. Note that the accumulator is the initial value &lt;code&gt;&amp;#91;&amp;#93;&lt;/code&gt;. So the computation unfolds from left to right, and once the end of the list is reached, it starts folding back from right to left, hence the name. Applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;&amp;#91;1,2,3&amp;#93;&lt;/code&gt; taking function &lt;code&gt;&amp;#40;&amp;#42;2&amp;#41;&lt;/code&gt; gives the list &lt;code&gt;&amp;#91;2,4,6&amp;#93;&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;map &amp;#40;&amp;#42;2&amp;#41; &amp;#91;1,2,3&amp;#93;
&amp;#40;&amp;#40;&amp;#91;&amp;#93; ++ &amp;#91;&amp;#40;&amp;#42;2&amp;#41; 1&amp;#93;&amp;#41; ++ &amp;#91;&amp;#40;&amp;#42;2&amp;#41; 2&amp;#93;&amp;#41; ++ &amp;#91;&amp;#40;&amp;#42;2&amp;#41; 3&amp;#93;
&amp;#91;&amp;#93; ++ &amp;#91;2&amp;#93; ++ &amp;#91;4&amp;#93; ++ &amp;#91;6&amp;#93; = &amp;#91;2,4,6&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href='#fn-5' id='fnref5'&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; &lt;a href='http://www.cs.nott.ac.uk/~pszgmh/pih.html'&gt;http://www.cs.nott.ac.uk/~pszgmh/pih.html&lt;/a&gt; &lt;a href='#fn-6' id='fnref6'&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt; &lt;a href='https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0'&gt;https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0&lt;/a&gt; &lt;ol class='footnotes'&gt;&lt;li id='fn-1'&gt;&lt;a href='#fnref1'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-2'&gt;&lt;a href='#fnref2'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-3'&gt;&lt;a href='#fnref3'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-4'&gt;&lt;a href='#fnref4'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-5'&gt;&lt;a href='#fnref5'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;li id='fn-6'&gt;&lt;a href='#fnref6'&gt;&amp;#8617;&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</link><title>Expressions vs statements</title><description>&lt;h1 id="expressions&amp;#95;vs&amp;#95;statements"&gt;Expressions vs statements&lt;/h1&gt;&lt;p&gt;The aim of this post is to clarify once and for all one of the most basic concepts in programming languages, yet often misunderstood or overlooked by many practitioner software developers: the difference between expressions and statements. &lt;strong&gt;Expressions&lt;/strong&gt; is a combination of the basic elements constituting a programming a language which evaluates to a value. &lt;strong&gt;Statements&lt;/strong&gt; are standalone units of execution which do not return any value. As such, it is clear that they are used to perform side effects in a program.&lt;/p&gt;&lt;h2 id="functional&amp;#95;vs&amp;#95;imperative"&gt;Functional vs imperative&lt;/h2&gt;&lt;p&gt;To get an overview of the different paradigms you can refer to article &lt;link to prog paradigms&gt;. Given the definitions above, it is clear that &lt;strong&gt;expressions&lt;/strong&gt; constitute the building blocks of the &lt;strong&gt;functional paradigm&lt;/strong&gt;, since everything should be always evaluated to give a value, and regardless of the time of invocation, given the same inputs should return same output values out of the expression. Statements, on the other hand, as said previously, are meant to provide side effects to the program, so it is clear that they can't exist in purely functional programs. On the other hand, &lt;strong&gt;statements&lt;/strong&gt; are fundamental blocks of the &lt;strong&gt;imperative&lt;/strong&gt; style (together with expressions) as they are used to alter the control flow of the program through constructs such as conditionals, loops, procedures.&lt;/p&gt;&lt;h2 id="examples"&gt;Examples&lt;/h2&gt;&lt;p&gt;Here follow a few examples to illustrate the differences outlined above.&lt;h3 id="if&amp;#95;conditionals"&gt;If conditionals&lt;/h3&gt; Some languages provide conditionals as expressions while others as statements; it is usually the case that languages that employ statements also provide an equivalent expression form (the ternary operator). If the conditional is an &lt;strong&gt;expression&lt;/strong&gt;, it is evaluated to value, which means that it can be for example assigned to a variable or passed as a function argument; basically, it can be treated as any other value. In standard ML one can write for example:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val acidity = if ph &amp;lt; 7 then &amp;quot;ACID&amp;quot; else if ph = 7 then &amp;quot;NEUTRAL&amp;quot; else &amp;quot;BASE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is clear that, being an expression, the conditional is required by the language to provide a value no matter what, thus all possible cases should be considered and a value should be returned for each. In this example the else branches are not optional, because if the ph level is greater or equals to 7, there must be some other value you return.&lt;/p&gt;&lt;p&gt;If the conditional is a &lt;strong&gt;statement&lt;/strong&gt;, it doesn't return a value, so for example it cannot be assigned to a variable, but it is a sort of logical block containing instructions with side effects. In Python you could write an if statement like this:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;acidity = ... # could be any value
...
if ph &amp;lt; 7:
	acidity = &amp;quot;ACID&amp;quot;
elif ph == 7:
	acidity = &amp;quot;NEUTRAL&amp;quot;
else:
	acidity = &amp;quot;BASE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This snippet shows that, no matter which branch is taken, the statement mutates the value of the variable &lt;code&gt;acidity&lt;/code&gt;. Note that it would be illegal syntax to assign this block to the variable &lt;code&gt;acidity&lt;/code&gt;. Finally, the language does not enforce you to provide a value for all the possible values of &lt;code&gt;ph&lt;/code&gt;, you could in fact only define the first if branch and ignore the other cases.&lt;/p&gt;&lt;h3 id="loops"&gt;Loops&lt;/h3&gt;&lt;p&gt;Imperative languages provide different constructs to loop over series of values or data structures (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, ...) which produce side effects. Functional languages instead do not provide a loop construct, but rely on the mechanism of recursion over data structures to implement it, since a value is returned out of it.&lt;/p&gt;&lt;h3 id="languages&amp;#95;mixing&amp;#95;both&amp;#95;paradigms"&gt;Languages mixing both paradigms&lt;/h3&gt;&lt;p&gt;It is now clear how languages that mix both the functional and imperative (e.g. object-oriented) styles make you define a certain construct either as an expression or as a statement respectively. For example, in Kotlin the body of a function can be defined as:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;functional style: &lt;code&gt;fun f&amp;#40;&amp;#41; = when {...}&lt;/code&gt; the body is an expression and when it is evaluated to produce a value, this is assigned to the function.&lt;/li&gt;&lt;li&gt;oo style:&lt;pre&gt;&lt;code&gt;fun f&amp;#40;ch: Char&amp;#41; {
	ch = ch + 1
	print&amp;#40;ch&amp;#41;
	return ch					
}
&lt;/code&gt;&lt;/pre&gt;the body is a statement composed of a sequence of instructions producing side effects.&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="wrap-up"&gt;Wrap-up&lt;/h2&gt;&lt;p&gt;We have seen that while expressions are evaluated to return a value, statements do not return any value, performing instead side effects. As such, programs written in the imperative style are constituted by both expressions and statements which implement some logic altering the state of the program (e.g. conditions, looping). The functional paradigm instead mandates the exclusive usage of expressions since by definition side effects are not admitted. The &lt;strong&gt;advantages&lt;/strong&gt; of using &lt;strong&gt;expressions over statements&lt;/strong&gt; is first of all that the program is contained from the side effects which would be introduced were you to use statements. Another advantage is that all constructs in the program are always evaluated to a value; as such, they can be passed around in the program as you would with simple values such as primitives or simple expressions. This favours composition, since the program itself is an expression made out of other expressions which produce a value. This means that the program can be passed around, returned or composed, allowing for further flexibility.&lt;/p&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2016-01-07-docs/</guid><link>https://robywan27.github.io/my-blog/posts/2016-01-07-docs/</link><title>Quick Start Guide</title><description>&lt;p&gt;This intro only documents a subset of Cryogen's features. For additional documentation please see the &lt;a href='http://cryogenweb.org'&gt;cryogen site&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="features"&gt;Features&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Blog posts and pages with Markdown (default) or AsciiDoc&lt;/li&gt;&lt;li&gt;Tags&lt;/li&gt;&lt;li&gt;Table of contents generation&lt;/li&gt;&lt;li&gt;Plain HTML page templates&lt;/li&gt;&lt;li&gt;Code syntax highlighting&lt;/li&gt;&lt;li&gt;Disqus support&lt;/li&gt;&lt;li&gt;Sitemap generation&lt;/li&gt;&lt;li&gt;RSS feed generation&lt;/li&gt;&lt;li&gt;Sass/SCSS compilation&lt;/li&gt;&lt;li&gt;Klipse Integration&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="prerequisites"&gt;Prerequisites&lt;/h2&gt;&lt;p&gt;You will need &lt;a href='https://github.com/technomancy/leiningen'&gt;Leiningen&lt;/a&gt; 2.5.0 or above installed.&lt;/p&gt;&lt;h2 id="usage"&gt;Usage&lt;/h2&gt;&lt;h3 id="creating&amp;#95;a&amp;#95;new&amp;#95;site"&gt;Creating a New Site&lt;/h3&gt;&lt;p&gt;A new site can be created using the Cryogen template as follows:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein new cryogen my-blog
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="running&amp;#95;the&amp;#95;server"&gt;Running the Server&lt;/h3&gt;&lt;p&gt;The web server can be started from the &lt;code&gt;my-blog&lt;/code&gt; directory using the &lt;code&gt;lein-ring&lt;/code&gt; plugin:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein ring server
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server will watch for changes in the &lt;code&gt;content&lt;/code&gt; and &lt;code&gt;themes&lt;/code&gt; folders and recompile the content automatically.&lt;/p&gt;&lt;p&gt;You can also generate the content without bringing up a server via:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;lein run
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="site&amp;#95;configuration"&gt;Site Configuration&lt;/h3&gt;&lt;p&gt;The site configuration file is found at &lt;code&gt;content/config.edn&lt;/code&gt;, this file looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class="clojure"&gt;{:site-title           &amp;quot;My Awesome Blog&amp;quot;
 :author               &amp;quot;Bob Bobbert&amp;quot;
 :description          &amp;quot;This blog is awesome&amp;quot;
 :site-url             &amp;quot;http://blogawesome.com/&amp;quot;
 :post-root            &amp;quot;posts&amp;quot;
 :page-root            &amp;quot;pages&amp;quot;
 :post-root-uri        &amp;quot;posts-output&amp;quot;
 :page-root-uri        &amp;quot;pages-output&amp;quot;
 :tag-root-uri         &amp;quot;tags-output&amp;quot;
 :author-root-uri      &amp;quot;authors-output&amp;quot;
 :public-dest          &amp;quot;public&amp;quot;
 :blog-prefix          &amp;quot;/blog&amp;quot;
 :rss-name             &amp;quot;feed.xml&amp;quot;
 :rss-filters          &amp;#91;&amp;quot;cryogen&amp;quot;&amp;#93;
 :recent-posts         3
 :post-date-format     &amp;quot;yyyy-MM-dd&amp;quot;
 :archive-group-format &amp;quot;yyyy MMMM&amp;quot;
 :sass-src             &amp;#91;&amp;#93;
 :sass-path            &amp;quot;sass&amp;quot;
 :compass-path         &amp;quot;compass&amp;quot;
 :theme                &amp;quot;blue&amp;quot;
 :resources            &amp;#91;&amp;quot;img&amp;quot;&amp;#93;
 :keep-files           &amp;#91;&amp;quot;.git&amp;quot;&amp;#93;
 :disqus?              false
 :disqus-shortname     &amp;quot;&amp;quot;
 :ignored-files        &amp;#91;#&amp;quot;\.#.&amp;#42;&amp;quot; #&amp;quot;.&amp;#42;\.swp$&amp;quot;&amp;#93;
 :previews?            false
 :posts-per-page       5
 :blocks-per-preview   2
 :clean-urls           :trailing-slash
 :collapse-subdirs?    false
 :hide-future-posts?   true
 :klipse               {}
 :debug?               false}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For information about each key please see the &lt;a href='http://cryogenweb.org/docs/configuration.html'&gt;"Configuration"&lt;/a&gt; portion of the Cryogen documentation site.&lt;/p&gt;&lt;h3 id="switching&amp;#95;between&amp;#95;markdown&amp;#95;and&amp;#95;asciidoc"&gt;Switching between Markdown and AsciiDoc&lt;/h3&gt;&lt;p&gt;Cryogen comes with Markdown support as default. If you want to use AsciiDoc instead, open the &lt;code&gt;project.clj&lt;/code&gt; in your created blog (e.g. &lt;code&gt;my-blog&lt;/code&gt;), and change the line in &lt;code&gt;:dependencies&lt;/code&gt; that says &lt;code&gt;cryogen-markdown&lt;/code&gt; to &lt;code&gt;cryogen-asciidoc&lt;/code&gt;. Instead of looking for files ending in &lt;code&gt;.md&lt;/code&gt; in the &lt;code&gt;content/md&lt;/code&gt; directory, the compiler will now look for files ending in &lt;code&gt;.asc&lt;/code&gt; in the &lt;code&gt;content/asc&lt;/code&gt; directory.&lt;/p&gt;&lt;h3 id="selecting&amp;#95;a&amp;#95;theme"&gt;Selecting a Theme&lt;/h3&gt;&lt;p&gt;The Cryogen template comes with three themes in the &lt;code&gt;themes&lt;/code&gt; folder. To change your blog's theme, change the value of the &lt;code&gt;:theme&lt;/code&gt; key in &lt;code&gt;config.edn&lt;/code&gt;. Note that the Nucleus theme is obtained from &lt;a href='http://www.downloadwebsitetemplates.co.uk/template/nucleus/'&gt;downloadwebsitetemplates.co.uk&lt;/a&gt; that requires you to keep the footer, unless you make a donation on their website.&lt;/p&gt;&lt;h3 id="customizing&amp;#95;layouts"&gt;Customizing Layouts&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://github.com/yogthos/Selmer'&gt;Selmer&lt;/a&gt; templating engine for layouts. Please refer to its documentation to see the supported tags and filters for the layouts.&lt;/p&gt;&lt;p&gt;The layouts are contained in the &lt;code&gt;themes/{theme}/html&lt;/code&gt; folder of the project. By default, the &lt;code&gt;base.html&lt;/code&gt; layout is used to provide the general layout for the site. This is where you would add static resources such as CSS and JavaScript assets as well as define headers and footers for your site.&lt;/p&gt;&lt;p&gt;Each page layout should have a name that matches the &lt;code&gt;:layout&lt;/code&gt; key in the page metadata and end with &lt;code&gt;.html&lt;/code&gt;. Page layouts extend the base layout and should only contain the content relaveant to the page inside the &lt;code&gt;content&lt;/code&gt; block. For example, the &lt;code&gt;tag&lt;/code&gt; layout is located in &lt;code&gt;tag.html&lt;/code&gt; and looks as follows:&lt;/p&gt;&lt;pre&gt;&lt;code class="xml"&gt;{% extends &amp;quot;/html/base.html&amp;quot; %}
{% block content %}
&amp;lt;div id=&amp;quot;posts-by-tag&amp;quot;&amp;gt;
    &amp;lt;h2&amp;gt;Posts tagged {{name}}&amp;lt;/h2&amp;gt;
    &amp;lt;ul&amp;gt;
    {% for post in posts %}
        &amp;lt;li&amp;gt;
            &amp;lt;a href=&amp;quot;{{post.uri}}&amp;quot;&amp;gt;{{post.title}}&amp;lt;/a&amp;gt;
        &amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id="code&amp;#95;syntax&amp;#95;highlighting"&gt;Code Syntax Highlighting&lt;/h3&gt;&lt;p&gt;Cryogen uses &lt;a href='https://highlightjs.org/'&gt;Highlight.js&lt;/a&gt; for code syntax highlighting. You can add more languages by replacing &lt;code&gt;themes/{theme}/js/highlight.pack.js&lt;/code&gt; with a customized package from &lt;a href='https://highlightjs.org/download/'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;The &lt;code&gt; initHighlightingOnLoad&lt;/code&gt; function is called in &lt;code&gt;themes/{theme}/html/base.html&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class="xml"&gt;&amp;lt;script&amp;gt;hljs.initHighlightingOnLoad&amp;#40;&amp;#41;;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="deploying&amp;#95;your&amp;#95;site"&gt;Deploying Your Site&lt;/h2&gt;&lt;p&gt;The generated static content will be found under the &lt;code&gt;public&lt;/code&gt; folder. Simply copy the content to a static folder for a server such as Nginx or Apache and your site is now ready for service.&lt;/p&gt;&lt;p&gt;A sample Nginx configuration that's placed in &lt;code&gt;/etc/nginx/sites-available/default&lt;/code&gt; can be seen below:&lt;/p&gt;&lt;pre&gt;&lt;code class="javascript"&gt;server {
  listen 80 default&amp;#95;server;
  listen &amp;#91;::&amp;#93;:80 default&amp;#95;server ipv6only=on;
  server&amp;#95;name localhost &amp;lt;yoursite.com&amp;gt; &amp;lt;www.yoursite.com&amp;gt;;

  access&amp;#95;log  /var/log/blog&amp;#95;access.log;
  error&amp;#95;log   /var/log/blog&amp;#95;error.log;

  location / {
    alias       /var/blog/;
    error&amp;#95;page  404 = /404.html;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Simply set &lt;code&gt;yoursite.com&lt;/code&gt; to the domain of your site in the above configuration and ensure the static content is available at &lt;code&gt;/var/blog/&lt;/code&gt;. Finally, place your custom error page in the &lt;code&gt;/var/blog/404.html&lt;/code&gt; file.&lt;/p&gt;&lt;p&gt;More information on deployment can be found &lt;a href='http://cryogenweb.org/docs/deploying-to-github-pages.html'&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;h2 id="third&amp;#95;party&amp;#95;libraries"&gt;Third Party Libraries&lt;/h2&gt;&lt;h4 id="https://github.com/greywolve/cryogen-markdown-external"&gt;https://github.com/greywolve/cryogen-markdown-external&lt;/h4&gt;&lt;p&gt;A Clojure library to provide Markdown rendering to the cryogen-core compiler by using an external command/program, such as pandoc.&lt;/p&gt;&lt;h2 id="some&amp;#95;sites&amp;#95;made&amp;#95;with&amp;#95;cryogen"&gt;Some Sites Made With Cryogen&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href='http://carmen.la/blog/archives'&gt;My personal blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://cryogenweb.org'&gt;Cryogen Documentation Site&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://yogthos.net/'&gt;Yogthos' blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.chadstovern.com'&gt;Chad Stovern's blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://www.szcz.org/'&gt;szcz&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://blog.isvit.info'&gt;ISvit blog&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='http://lambdafunk.com'&gt;Lambda Funk&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://ddft.wiki'&gt;DDFT.wiki&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description><pubDate>Thu, 07 Jan 2016 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2014-11-04-second-post/</guid><link>https://robywan27.github.io/my-blog/posts/2014-11-04-second-post/</link><title>Yet Another Post</title><description>&lt;h3 id="this&amp;#95;post&amp;#95;so&amp;#95;fetch"&gt;This Post So Fetch&lt;/h3&gt;&lt;p&gt;some more stuff happened&lt;/p&gt;</description><pubDate>Tue, 04 Nov 2014 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2014-03-10-first-post/</guid><link>https://robywan27.github.io/my-blog/posts/2014-03-10-first-post/</link><title>A Post</title><description>&lt;h3 id="this&amp;#95;post&amp;#95;not&amp;#95;fetch&amp;#95;enough"&gt;This Post Not Fetch Enough&lt;/h3&gt;&lt;p&gt;some stuff happened&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt; Stop trying to make fetch happen. &lt;/p&gt;&lt;footer&gt; Regina&lt;/footer&gt;&lt;/blockquote&gt;</description><pubDate>Mon, 10 Mar 2014 00:00:00 +0100</pubDate></item></channel></rss>