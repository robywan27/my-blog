<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><atom:link href="https://robywan27.github.io" rel="self" type="application/rss+xml"/><title>roby-wan $ ramblings</title><link>https://robywan27.github.io</link><description>Personal blogging site about topics in the landscape of programming languages, software development, computer science</description><lastBuildDate>Sun, 24 Nov 2019 17:56:40 +0100</lastBuildDate><generator>clj-rss</generator><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-20-best-programming-language-to-start-off/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-20-best-programming-language-to-start-off/</link><title>Best programming language to start off?</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;I start off by saying it depends to make things clear. It depends on the prospective you have about what you are going to us programming for. Some factors to consider are for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;do you want to create a career out of programming or is it going to be just a hobby&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;are you seeing yourself programming in the long-term or just short-term&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;do you need a quick introduction to get you started soon or are you willing to dedicate more time to understand the craft more deeply&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Based on the aforementioned points I would propose the followign suggestions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_python"&gt;Python&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is going to apply for perhaps the majority of the people willing to learn to program. The reason for this is that many of these people are likely to not start a career as software developers, while they will need to program for other applications. Nowadays anyone doing anything related to science or statistics is going to need to use scientific langauges such as Matlab, R or Python. Another reason why Python is a good choice for beginners is the simple, concise and terse syntax coupled with it being high-level which allow the developer to forego details which afflict other languages (e.g. low-level operations for C-like languages or OO syntax for Java-like languages). You can write Python code straight away in just few lines of code without any unnecessary boilerplate. The language is powerful enough though, and allows you to exploit additional paradigms and approaches to make the code more complex.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_javascript"&gt;Javascript&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is also going to be one of the most popular choices, in particular for those people willing to make a career out of writing software. Most software development jobs are web and Javascript is king in the web. In the last decade it has risen in prominence like no other language. What makes this language suited to new developers is also the fact that it is still mainly used for front-end development, which is usually less geeky and techy than other kinds of development roles. This results in a more vibrant and heterogenous community, which I think is a strong point in favor. As the language per se, however, I don&amp;#8217;t consider it to be the optimal choice, since the plain lanaguage is far from being straightforward and consistent. Many of its quirks confuse even the most seasoned Javascript developers. And it requires a thorough understanding of many of its mechanisms to properly master the language; I think it is one of the most deceiving langauges in that it seems to be simpler than it actually is (for a further understanding of the language I advise Kyle Simpson&amp;#8217;s books &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;). Moreover, nowadays the ecosystem which revolts around it is daunting, and it is likely you will immediately be faced with several other technologies when working with Javascript.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_c"&gt;C&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I think C language might be the best choice if you plan to get a thorough foundation of programming, since it is lower level than most languages out there. You are going to do things such as manually dealing with memory yourself, which is complex and requires a lot of experience and good thinking. It however gives you a glipmse of how things work are managed down there while other languages provide an abstraction on top of it. It is also a procedural language, which means that you are not going to deal with any object-oriented or functional concept making it easier to focus on the essence of programming.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_scheme"&gt;Scheme&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This could be a great choice if you want to get exposed to the functional and declarative thinking early on in your journey. I don&amp;#8217;t know how this actually affects the mind and the approach since my first langauge was C. The different syntax and approach on programming of Scheme, which are fairly different from most other languages, may make the transition to any other language more difficult at the beginning. However, Scheme can be a great choice as it allows you to learn Lisp (defined the most powerful language of all &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote."&gt;3&lt;/a&gt;]&lt;/sup&gt;) devoid of any other pre-concept from other langauges. Another great point in favor of this choice, is that &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote."&gt;4&lt;/a&gt;]&lt;/sup&gt; has been written in this language.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_haskell"&gt;Haskell ?&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I am not sure about this choice, but Haskell could also be a valid alternative if you plan on learning the functional approach with a pure functional language. Also I find it very concise, which is good when you are starting out so that you don&amp;#8217;t get distracted by unnecessary syntactic details. The problem with it could be that it quickly escalates into category theory (monads and all its friends) as soon as you want to do something more useful such as reading/writing or dealing with uncertain operations, which may be fairly confusing, especially for the not so mathematically well-versed audience. It could be good though for mathematicians.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_what_is_not_a_good_choice"&gt;What is not a good choice&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;There are some language which I consider not to be a good choice as first language to learn programming.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_java"&gt;Java&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Java is deeply object-oriented flavored, in that even the usual Hello World program requires you to set up a class and a method. It is also highly verbose, which may be distracting if you plan on learning the essence of the logic behind programming. I believe Java is a good choice if you want to learn object-oriented programming (in a statically-typed language), but I personally think the object-oriented paradigm should be learned after learning the procedural one with C or Python or the functional with Scheme&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_c_2"&gt;C++&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I woudl say C is by no means the best way to start learning programming, as it is notoriously over-complicated and is huge. C would definitely be a better choice since it is just a small subset of C. C++ could be the natural continuation after learning C if you plan to use it for your applications (e.g. embedded, video-games, gaphics).&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://github.com/getify/You-Dont-Know-JS" class="bare"&gt;https://github.com/getify/You-Dont-Know-JS&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="http://www.paulgraham.com/icad.html" class="bare"&gt;http://www.paulgraham.com/icad.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_3"&gt;
&lt;a href="#_footnoteref_3"&gt;3&lt;/a&gt;. &lt;a href="https://twobithistory.org/2018/10/14/lisp.html" class="bare"&gt;https://twobithistory.org/2018/10/14/lisp.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_4"&gt;
&lt;a href="#_footnoteref_4"&gt;4&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Wed, 20 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-19-resources-to-level-up-as-a-developer/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-19-resources-to-level-up-as-a-developer/</link><title>Resources to level up as a developer</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;This post is related to the one I wrote here &lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-19-on-selecting-relevant-learning-content/"&gt;On selecting relevant learning content&lt;/a&gt;, but is going to advise some reources which have been useful to me. Like I said in the other post, a problem I see this day is that many developers favor articles or tutorials over resources with more substance as they provide a quick and handy explanation which can be immediately applied. Books are most often not read. The post &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; from famous development blog &lt;em&gt;Coding Horror&lt;/em&gt; reveals that &lt;strong&gt;one book is more than most programmers read each year&lt;/strong&gt;. Even though the post is more than years old now and the reference even older, I believe it is still relevant to this day, if not even worse. The pace at which new technology (language, framework, whatever) is churned out is faster nowadays and countless of resources promising the shortest path to learn something are available online (more on this in my post  However, I believe that reading books is fundamental. The reason for this, is that books can teach you concepts; they may not give you the information to get you up and running with a working solution for the scenario at hand, but give you the mental foundations for tackling problems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Books are not the only relevant resources out there though, some excellent online courses have been created. I particularly like Coursera and edX since most of their courses are backed by Universities. Having graduated from University myself I recognize the added value which learning theory and concepts provide you. And being the instructors usually professors themselves, they are professionals in teaching and crafting valuable learning material.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here follow some of my recommendations on two main areas, namely software engineering and programming languages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_software_engineering"&gt;Software Engineering&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I find that books are fundamental for learning the best practices of software engineering, which is more a practice than a science. Some books are considered essential readings for the practicioner software developer as they distill in some pages the lessons and teachings learned through countless struggles and trials. Some are also quite encyclopedic in scope as they report some conclusions from studies and surveys conducted by researchers of the field. Authoritative sources of knowledge can be easily found with a query in the Internet. Some of these books include for example &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote."&gt;3&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote."&gt;4&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_5" class="footnote" href="#_footnote_5" title="View footnote."&gt;5&lt;/a&gt;]&lt;/sup&gt;. Note that these books are heavily skewed towards object-oriented programming, which was the de-facto industry standard at the time of their writing, as it is still today. One thing I can advise is to consult these books as they provide valuable lessons, but to always weigh them on the basis of your personal judgements. After all, they consist of opinions, not holy truths. I think in particular with &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_6" class="footnote" href="#_footnote_6" title="View footnote."&gt;6&lt;/a&gt;]&lt;/sup&gt; there may be many points which provide room for disagreement with the author as (grumpy) Uncle Bob is at times very inflexible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Like I said, the aforementioned books focus on the object-oriented paradigm and the imperative approach. If you limit to these books only, you would only get a partial picture. I think it is fundamental that developers get acquainted with different paradigms and approaches as they provide different perspectives to solve problems. The resource I advise so warmly that I have dedicated a series of posts on it (&lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-intro/"&gt;SICP Series Intro&lt;/a&gt;) is &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_7" class="footnote" href="#_footnote_7" title="View footnote."&gt;7&lt;/a&gt;]&lt;/sup&gt;. Additional excellent material is also available here &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_8" class="footnote" href="#_footnote_8" title="View footnote."&gt;8&lt;/a&gt;]&lt;/sup&gt;. I am not going to spend much time on it here because I have been talking more profusely in other articles, but I just think it is probably the most essential reading for a software developer to really understand and appreciate the craft. It also exposes the reader to the functional paradigm.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_programming_languages"&gt;Programming Languages&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;On the topic of programming languages, I have found two online MOOCs to be particularly useful. The online series &lt;strong&gt;Programming Lanauges&lt;/strong&gt; from Prof. Dan Grossman available on &lt;strong&gt;Coursera&lt;/strong&gt; here &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_9" class="footnote" href="#_footnote_9" title="View footnote."&gt;9&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_10" class="footnote" href="#_footnote_10" title="View footnote."&gt;10&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_11" class="footnote" href="#_footnote_11" title="View footnote."&gt;11&lt;/a&gt;]&lt;/sup&gt; do an amazing job in exposing the fundamental concepts of programming languages. The courses cover both the functional and object-oriented paradigms and also deal with the distinction between statically-typed languages and dynamically-typed languages. What I find valuable the most is the comparison the instructor makes among languages implementing different approaches and type rules, as there is no &lt;em&gt;better language&lt;/em&gt; or &lt;em&gt;better approach&lt;/em&gt;, while each has it s own strengths and weaknesses, similarities and differencies.
Another online course I found useful is the &lt;strong&gt;Functional Programming&lt;/strong&gt; course on &lt;strong&gt;edX&lt;/strong&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_12" class="footnote" href="#_footnote_12" title="View footnote."&gt;12&lt;/a&gt;]&lt;/sup&gt;. This course exposes you to the main concepts of the functional paradigm by focusing on a purely functional language, Haskell. This is a great choice as with other non pure functional language you would have to deal also with the non-functional or imperative parts. What makes this course valuable is the academic approach the stuff have chosen to adopt (the main instructor is a big shot in the field of programming languages research), which help providing a more solid theoretical foundation, which is highly beneficial for functional programming. The course is also enriched by a good number of theoretical exercises which makes you use your head instead of just typing on the keyboard.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_take_home"&gt;Take-home&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Overall, I think that it is fundamental to get familiar with the fundamental underlying concepts in programming languages, since it provides the theoretical framework to the devloper to quickly switch from one language to the other and understanding the similarities and differences. Coupled with a SOLID (pun intended) understanding of the best practices and heuristics in software engineering will certainly make you a better developer. This is my belief.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://blog.codinghorror.com/programmers-dont-read-books-but-you-should/" class="bare"&gt;https://blog.codinghorror.com/programmers-dont-read-books-but-you-should/&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://www.goodreads.com/book/show/85009.Design_Patterns" class="bare"&gt;https://www.goodreads.com/book/show/85009.Design_Patterns&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_3"&gt;
&lt;a href="#_footnoteref_3"&gt;3&lt;/a&gt;. &lt;a href="https://en.wikipedia.org/wiki/Code_Complete" class="bare"&gt;https://en.wikipedia.org/wiki/Code_Complete&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_4"&gt;
&lt;a href="#_footnoteref_4"&gt;4&lt;/a&gt;. &lt;a href="https://www.goodreads.com/book/show/3735293-clean-code" class="bare"&gt;https://www.goodreads.com/book/show/3735293-clean-code&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_5"&gt;
&lt;a href="#_footnoteref_5"&gt;5&lt;/a&gt;. &lt;a href="https://martinfowler.com/books/refactoring.html" class="bare"&gt;https://martinfowler.com/books/refactoring.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_6"&gt;
&lt;a href="#_footnoteref_6"&gt;6&lt;/a&gt;. &lt;a href="https://www.goodreads.com/book/show/3735293-clean-code" class="bare"&gt;https://www.goodreads.com/book/show/3735293-clean-code&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_7"&gt;
&lt;a href="#_footnoteref_7"&gt;7&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_8"&gt;
&lt;a href="#_footnoteref_8"&gt;8&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_9"&gt;
&lt;a href="#_footnoteref_9"&gt;9&lt;/a&gt;. &lt;a href="https://www.coursera.org/learn/programming-languages" class="bare"&gt;https://www.coursera.org/learn/programming-languages&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_10"&gt;
&lt;a href="#_footnoteref_10"&gt;10&lt;/a&gt;. &lt;a href="https://www.coursera.org/learn/programming-languages-part-b" class="bare"&gt;https://www.coursera.org/learn/programming-languages-part-b&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_11"&gt;
&lt;a href="#_footnoteref_11"&gt;11&lt;/a&gt;. &lt;a href="https://www.coursera.org/learn/programming-languages-part-c" class="bare"&gt;https://www.coursera.org/learn/programming-languages-part-c&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_12"&gt;
&lt;a href="#_footnoteref_12"&gt;12&lt;/a&gt;. &lt;a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" class="bare"&gt;https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Tue, 19 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-19-on-selecting-relevant-learning-content/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-19-on-selecting-relevant-learning-content/</link><title>On selecting relevant learning content</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;One of the blessings of working as software developers is that we are constantly pushed to expand our knowledge and explore new things. The learning process never ends, there are just too many programming languages, frameworks, libraries and any other technological artifact than is possible to learn within a lifetime, and besides new ones are created by the day. As such, an endless amount of learning resources have been produced and is being produced, with the result that it can become difficult to navigate in the sea of information and select the most relevant resources. A choice should be made as it is simply unfeasible to consult anything available.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is indeed a great struggle to create great content in the IT field, given its relentless fast pace. A book is becoming obsolete and outdated the moment it touches the shelves. Besides, many publishers support the publication of books which favor fast and easy learning which is appetizing to many developers and novices. For example, many times I have seen a new book on a given programming language, sometimes with the pretense of focusing on a new edition, doing the usual round up of the syntax and basic elements of the language; the problem is that it covers most of the content of the book. I find it particularly amusing when I read titles such as "Learn language X in Y amount of time", like, really? In such a short amount of time, you could perhaps get familiar with the syntax, but languages are not only syntax. That is the easiest part. What a book or tutorial should teach is instead the idioms which the language brings to the table in order to solve problems thinking in that language instead of treating that language simply as a syntactic replacement for any of the known languages by the developer. In case the book covers a new edition of a language, the author should instead focus on the  novel features of the new version and how it differentiates or relates to the previous versions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Internet has given the opportunity to people without any publishing deal to write their own content. More recently, platforms such as Medium, Hackernoon, Towards Data Science have granted the possibility to literally anyone with a PC and an Internet connection to publish content. Note that I am in favour of the democratization of knowledge as a way of empowerment of the individual and I believe everyone should be given the opportunity to spread his ideas. However, the downside of this is that it can lead to the viral spread of poor quality material which contribute to add up more noise in the information available. Many times, articles and tutorials lack quality and may even be inaccurate or wrong.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I conclude this post with some advices to the reader.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Make an investment in time to research the best resources on the topic at hand.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Always opt for resources teaching concepts over superficial details.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tutorials should be preferably used as references or ancillary learning material, but not as exclusive learning method.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get familliar with the fundamental concepts of programming languages and software engineering by reading classic books or picking excellent resources (e.g. MOOCs), the Internet forums are full of recommendations.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make sure the resource you have picked is suited to your learning style, it would be even worse to pick some resource because it is considered as authorative, but struggling to go through it. Practicality should be the first concern in any case.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In any case, be selective and judgemental in picking up the right resources which provide the information needed in an efficient and effective manner.&lt;/p&gt;
&lt;/div&gt;</description><pubDate>Tue, 19 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-is-computer-science-the-right-name/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-is-computer-science-the-right-name/</link><title>Is computer science the right name?</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;In this post I am not going to be technical, but I am willing to offer some food for thought. As you may have noticed, I have been enthralled by the masterpiece &lt;code&gt;Structure and Interpretation of Computer Programs&lt;/code&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;. In the very first video lecture &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; Prof. Abelson begins the lesson by stating something very interesting. He claims that &lt;code&gt;computer science&lt;/code&gt; is actually not an apt name for such discipline. First off, it is not really science, rather it is engineering or art. Secondly, it is not about computers. Abelson goes on comparing it with other disciplines, stating that computer science is about computers as much as geometry is about measurement instruments or biology about microscopes. I end the post with the following quote to reflect on:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
"When a field is just getting started, it&amp;#8217;s easy to confuse the essence of the field with its tools."
&lt;/blockquote&gt;
&lt;div class="attribution"&gt;
&amp;#8212; Hal Abelson
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-data-abstraction/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-data-abstraction/</link><title>SICP series - Data Abstraction</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The previous post &lt;a href="robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-procedural-abstraction/"&gt;Procedural Abstraction&lt;/a&gt; dealt with the idea of creating procedures to capture patterns of computation and abstracting them away by suppressing the implementation details and giving them a name so taht it is possible to treat them as primitive elements of the language. The topic of this post tackles a complementary issue to that of procedure abstraction, specifically how to group together pieces of information or data into abstract structures. Even though the problems both sides of abstraction are complementary, it will turn out that they are actually interconnected and thus the distinction among them is blurred. In fact, the procedures to manipulate the elements of a data structure usually have an inherent structure that mimics the data structure. This is just a teaser, but I will come back on this more in detail later.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_compound_data"&gt;Compound Data&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is sometimes handy if we can use data elements which differ from the basic primitives the language provides you. Therefore, there needs to be a way for us to define and use our own data structures, in particular compound data structures. So there needs to be a way to glue simple elements together to form a compound structure which can be treated as a unit piece of primitive data element as well as a way to pull the compound structure&amp;#8217;s constituent pieces apart. This compound structure should be treated as a single unit, which means that it should be possible to pass it as argument and return as a value. This leads to the concept of &lt;code&gt;closure&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;closure&lt;/strong&gt;: &lt;em&gt;"the result obtained by creating a compound data structure can itself be treated as a primitive object and thus be input to the creation of another compound object"&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_pairs"&gt;Pairs&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Scheme provides a basic construct to glue things together, &lt;code&gt;cons&lt;/code&gt; (constructor). &lt;code&gt;cons&lt;/code&gt; is a procedure which takes two expressions as input, evaluates them and glues those values together to form a &lt;code&gt;pair&lt;/code&gt;. In order to get those elements back from the pair Scheme provides the procedures &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; which return the first and second element respectively. Furthermore, the contract can be extended to include &lt;code&gt;operations&lt;/code&gt; such as &lt;code&gt;predicates&lt;/code&gt; to check if a given data structure satisfies the contract or not. So the &lt;code&gt;contract&lt;/code&gt; may look like this.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(cons &amp;lt;x-exp&amp;gt; &amp;lt;y-exp&amp;gt;) ==&amp;gt; &amp;lt;P&amp;gt;  ; constructor
(car &amp;lt;P&amp;gt;) ==&amp;gt; &amp;lt;x-val&amp;gt;           ; accessor
(cdr &amp;lt;P&amp;gt;) ==&amp;gt; &amp;lt;y-val&amp;gt;           ; accessor
(pred? &amp;lt;x&amp;gt;)                     ; predicate
  ==&amp;gt; #t if pred? evaluates to a pair, else #f&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To portrait an implementation of a contract, the most basic example we could think is that of a 2-D point.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (make-point x y)
  (cons x y))
(define (point-x p)
  (car p))
(define (point-y p)
  (cdr p))
(define (pair? p)
  (; check details))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_lists"&gt;Lists&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Scheme provides another primitive way of gluing together elements, the &lt;code&gt;list&lt;/code&gt;. A list is a data structure that can hold an arbitrary number of ordered items. It is in practice implemented under the hood as a sequence of pairs with the following properties:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;car-part of a pair in sequence - holds an item&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cdr-part of a pair in sequence - holds a pointer to the rest of the list&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;empty-list nil - signals no more pairs or end of the list&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="imageblock text-center"&gt;
&lt;div class="content"&gt;
&lt;img src="../../img/scheme-lists.png" alt="Scheme Lists"&gt;
&lt;/div&gt;
&lt;div class="title"&gt;Figure 1. Lists in Scheme&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that lists are closed under the operations of &lt;code&gt;cons&lt;/code&gt;, &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt;, and can thus be treated as primitives.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Several procedures can be written to define operations on lists; one thing they share is their recursive structure which mimics the recursive structure of the data object.
For example, consider the &lt;code&gt;append&lt;/code&gt; operation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (append l1 l2)
  (if (null? l1)
    l2
    (adjoin (first l1)
      (append (rest l1) l2))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;where &lt;code&gt;adjoin&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;rest&lt;/code&gt; are defined in terms of &lt;code&gt;cons&lt;/code&gt;, &lt;code&gt;car&lt;/code&gt; and &lt;code&gt;cdr&lt;/code&gt; for lists:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define adjoin cons)
(define first car)
(define rest cdr)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_take_home"&gt;Take-home&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As seen with pairs and lists, it is possible to build systems which rely on layers of abstractions barriers, creating a sort of hierarchy of data abstractions. For example, lists are composed of pairs and groups could be defined in terms of lists. regardless of the level, the user to use only those operations exposed for a given level of abstraction without messing with the procedures of the implementation of that structure. This leads to the benefit that the user is shielded by the implementation details of the underlying representation of a given structure. Which means that alternative implementations could be provided without the user ever noticing it, provided that the contract is respected.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_abstract_data_types"&gt;Abstract Data Types&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In Scheme it is possible to create tagged data structures by combining &lt;code&gt;symbols&lt;/code&gt; (tags) with data structures. Symbols are data objects which, when evaluated, refer to the name itself rather than the value associated to it. Mixing tags with data structures leads to two major benefits:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;data-directed programming&lt;/code&gt; - functions that select the right operations based on the arguments&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;defensive programming&lt;/code&gt; - functions that fail gracefully if given bad arguments&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Procedures following the data-directed programming approach first check the tag of a data object to choose the right sub-procedure designed specifically to to handle data of that given type. This leads to more modular systems, as procedures can be decomposed in specialized sub-components rather than having to deal with any possible type by themselves. With defensive programming procedures check the type of the arguments and produce an error message in case of an unexpected data object has been passed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;With these concepts in mind it is then possible to define &lt;code&gt;abstract data types&lt;/code&gt; (ADTs). An example could be an ADT for sums. Some of the procedures which could be defined for implementing it could be for example sake.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (make-sum addend augend)
  (list '+ addend augend'))
(define (sum-exp? e)
  (and (pair? e) (eq? (car e) '+')))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The first procedure defines a tagged-data structure &lt;code&gt;make-sum&lt;/code&gt; prefixed by the symbol &lt;code&gt;+&lt;/code&gt;. The second procedure exploits defensive programming as it first checks the argument to see if it is a pair. In case it is not, then it just returns false. If it is a pair, it proceeds to check whether the first element of the list is the symbol &lt;code&gt;+&lt;/code&gt;.
We could implement a simple evaluator function like this&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (eval e)
  (cond
    ((number? e) e)
    ((sum-exp? e)
      (+ (eval (sum-addend e))
         (eval (sum-augend e))))
    (else
      (error "unknow expression " e))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In this excerpt we have exploited data-directed programming to check the expressions types looking for the primitive types first. If the expression is not a number, we resort to defensive programming to check if the expression is a sum.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-procedural-abstraction/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-procedural-abstraction/</link><title>SICP series - Procedural Abstraction</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The previous article &lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-introductory-concepts/"&gt;Introductory Concepts&lt;/a&gt; exposed procedures as basic components to capture processes. Scheme provides one mechanism to define procedures: the &lt;code&gt;lambda expression&lt;/code&gt;. The purpose of this element is to capture common patterns of computation into the body of the procedure. For example in order to group any pattern of the form&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(* 3 3)
(* 5 5)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;the following lambda expression can be used&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(lambda (x) (* x x))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;to capture the &lt;em&gt;double an element&lt;/em&gt; process. It consists of two components, namely the &lt;em&gt;parameters&lt;/em&gt; and the &lt;em&gt;body&lt;/em&gt; which is evaluated to a value. The lambda expression can be combined with the naming abstraction of the previous article to provide a name to the procedure. The previous expression can then be rewritten in the following manner&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define square (lambda (x) (* x x)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is thus possible to use the procedure by simply calling it by its name, like &lt;code&gt;(square 5)&lt;/code&gt;, which gives the result &lt;code&gt;25&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The following steps provide an overview of the steps to abstract processes:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;identify modules or stages of a process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;capture each module within a procedural abstraction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;construct a procedure to control the interactions between the modules&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;repeat the process within each module as necessary&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_abstraction_and_modularity"&gt;Abstraction and Modularity&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;By means of the procedure, we can treat processes as black boxes in which the implementation details are hidden and detached from the use of the procedure, which can simply be referred by its name or lambda expression. The procedure also exposes a &lt;code&gt;contract&lt;/code&gt;, according to which for given inputs of the provided type an output of the specified type will be given. So the black box abstraction hides the details of this contract for converting input to output.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another important concept which allow to create modular systems is that of &lt;code&gt;block structures&lt;/code&gt;. It consists in defining procedures inside the body of the lambda expression of a given procedure; by doing so, the internal procedures are accessible only to other expressions within the body of the lambda, but inaccessible outside the scope ofthe procedure. This is important, because internal procedures become part of the implementation details of procedures giving them a higher abstraction power.
A trivial example to illustrate the concept can be the following one hiding the &lt;em&gt;square&lt;/em&gt; lambda inside the &lt;em&gt;sum of squares&lt;/em&gt; procedure. Note that normally it would be arguable whether the &lt;em&gt;square&lt;/em&gt; procedure should be made private as it can be useful anywhere in the system, but I will stick to this example for simplicity sake.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (sum-of-squares a b)
  (define (square x)
    (* x x))
  (+ (square a) (square b))
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_higher_order_functions"&gt;Higher-order Functions&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Higher-order procedures bring the concept of procedure abstraction to the next level by capturing common procedural patterns. They take other procedures as arguments or return one as value. This allows to further increase the modularity of the system. As an example let&amp;#8217;s consider different patterns of sum such as the following ones&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (sum-integers a b)
  (if (&amp;gt; a b)
    0
    (+ a (sum-integers (+ 1 a) b))))
(define (sum-squares a b)
  (if (&amp;gt; a b)
    0
    (+ (square a) (sum-squares (+ 1 a) b))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear both procedures share the same form, so they can be distilled into the following higher-order procedure&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (sum term a next b)
  (if (&amp;gt; a b)
    0
    (+ (term a) (sum term (next a) next b))))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Both &lt;code&gt;term&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; are procedures and are passed as arguments to &lt;code&gt;sum&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_recursive_and_iterative_processes"&gt;Recursive and iterative processes&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The last topic of this post regards the shape a process can assume, which could either be recursive or iterative. The shape of the process determines some of its characteristics such as the space and time complexity. The following two paragraphs are going to go more in detail on each approach.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_recursive_processes"&gt;Recursive Processes&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A recursive process is characterized by a set of deferred operations as long as the computation does not reach the base case; once that point is reached, the stacked up operations are accumulated to give the final result. For example consider the shape for the factorial operation&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(fact 3)
(* 3 (fact 2))
(* 3 (* 2 (fact 1)))
(* 3 (* 2 (* 1)))
(* 3 (* 2))
6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The implementation of the factorial procedure is&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define fact
  (lambda (n)
    (if (= n 1)                 # test base case
      1                         # base case
      (* n (fact (- n 1))))))   # recursive case&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear that the algorithm grows linearly with the size of the argument in both space and time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The steps to design recursive algorithms are the following ones:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="olist arabic"&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;
&lt;p&gt;wishful thinking - assume you have avilable a procedure that solves the problem for smaller versions of it&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;decompose the problem - use the solution to smaller sized problems with some operations to get the solution to the larger sized problem&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;identify non-decomposable problems - identify the smallest problem, i.e. base case&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_iterative_processes"&gt;Iterative Processes&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Contrary to the recursive process, iterative processes do not require to keep track of deferred operations, but perform the computations without using any additional memory. For this reason additional parameters are needed to store the current state of the computation such as counters and temporary values.
A possible shape for the iterative factorial algorithm is the following one&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(ifact 3)
(if (&amp;gt; 1 3) 1 (ifact-helper (* 1 1) (+ 1 1) 3))
(if (&amp;gt; 2 3) 1 (ifact-helper (* 1 2) (+ 2 1) 3))
(if (&amp;gt; 3 3) 2 (ifact-helper (* 2 3) (+ 3 1) 3))
(if (&amp;gt; 4 3) 6 (ifact-helper (* 6 4) (+ 4 1) 3))
6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;for the procedure&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define ifact-helper
  (lambda (product counter n)
    (if (&amp;gt; counter n)
      product
      (ifact-helper (* product counter)
                    (+ counter 1)
                    n))))
(define ifact (lambda (n) (ifact-helper 1 1 n)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The algorithm grows constantly in space and linearly with the size of the argument in time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To develop an iterative algorithm the following recipe can be followed:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;determine a way to accumulate partial answers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write a table to analyze&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;initialization of first row&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;update rules for other rows&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how to know when to stop&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;translate rules in Scheme&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-metacircular-evaluator/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-metacircular-evaluator/</link><title>SICP series - Metacircular Evaluator</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;So far in this series we have seen that abstractions allow to hide details and create modules to model complex systems. Abstraction can be obtained by building procedures which capture patterns of computation and data structures made out of simpler components. Although they tackle complementary issues, the distinction between both kinds of abstraction are blurred and share a common structure. In the previous &lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-mutation-and-environment-model/"&gt;post&lt;/a&gt; we have drawn a comparison between the functional approach and a state-based one characterized by side effects. We have then formulated the environment model as model of evaluation to take into account mutation. Building on this last concept, we are going to delve into the central topic of the book: &lt;code&gt;meta-linguistic abstractions&lt;/code&gt;. This topic deals both with the definition of a new language and with the process of evaluation of a program. This is the ultimate step in the process of abstraction, as it allows not only to combine and abstract over the primitive elements of a language, but to define new languages which introduce different primitives and consequently new ways of combination and abstraction tailor-suited to different kinds of problems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_interpreter"&gt;Interpreter&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In order to deduce the meaning associated to the expressions in a language, we need to define a set of procedures which compose what we call an &lt;code&gt;interpreter&lt;/code&gt; or evaluator. An interpreter is then a program which is able to unwind the means of abstraction in a language and reduce them into means of combination or primitives of the language. It specifies what it means to evaluate expressions in this language, so it defines what is legal syntax or legal semantics.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_structure_of_an_interpreter"&gt;Structure of an interpreter&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;An interpreter is composed of a series of components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Lexical analyzer&lt;/code&gt;: maps a string of characters to a sequence of words (tokens).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Parser&lt;/code&gt;: parses the sequence of words into a defined structure useful for the subsequent phase. An example of representation is a tree structure made up of pairs.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Evaluator&lt;/code&gt;: works hand-in-hand with an environment, a sort of dictionary associating names to values. The evaluator employs a set of rules to reduce complex expressions to simpler elements until a simple value is returned.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Printer&lt;/code&gt;: converts the returned value in the appropriate form (e.g. a string) and displays it to the user.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is possible to exploit Scheme to take care of some of the steps of the interpretation process to avoid to build them from scratch. So we will focus only on the &lt;code&gt;evaluator&lt;/code&gt;, the core of the evaluation process. This means that we will need to build a language resembling Scheme in that it should have a tree structure as the output of the parser and a set of rules for manipulating that tree structure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_eval_apply"&gt;Eval-Apply&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The evaluator is composed of several functions to evaluate different elements of the language, and a function to apply procedures on the evaluated arguments. It is the interplay of this &lt;code&gt;eval-apply&lt;/code&gt; cycle that makes up the core of the process of evaluation:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="quoteblock"&gt;
&lt;blockquote&gt;
The &lt;em&gt;evaluation&lt;/em&gt; of an expression with respect to an environment reduces to an &lt;em&gt;application&lt;/em&gt; of a procedure to a set of arguments. This in turn reduces to the &lt;em&gt;evaluation&lt;/em&gt; of a simpler expression, the body of the procedure, with respect to a new environment (one in which the formal parameters of the procedure have been bound to the arguments passed in). The loop continues unwinding expressions until it reaches the &lt;em&gt;application&lt;/em&gt; of a primitive procedure to primitive values or the &lt;em&gt;evaluation&lt;/em&gt; of a primitive data object.
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="imageblock text-center"&gt;
&lt;div class="content"&gt;
&lt;img src="../../img/eval-apply-cycle.png" alt="eval-apply cycle"&gt;
&lt;/div&gt;
&lt;div class="title"&gt;Figure 1. eval-apply cycle&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that it is important to exploit data abstraction to define the elements on which the evaluation procedures work in order to separate the syntax of the language from its semantics. This is useful as it allows to change the syntax of the language without having to change the evaluator, i.e. the semantics. So for example to implement the syntactic change to function calls it is necessary to just change the procedures dealing with the syntax, i.e. those walking the tree structure and pulling out the pieces.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_metacircular_evaluator"&gt;Metacircular Evaluator&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We have talked so far how it is possible to create languages within Scheme by defining an evaluator which defines some procedures to implement the &lt;em&gt;eval-apply&lt;/em&gt; cycle. For example, it is possible to define a language for processing arithmetic expressions which resembles Scheme. However, this is not all. In fact, it is actually possible to write the actual Scheme evaluator with Scheme itself! This is what has been named by the authors of the book as &lt;code&gt;metacircular evaluator&lt;/code&gt;, since writing the interpreter in a language is equivalent to defining the language itself.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To build a complete evaluator of Scheme, it is necessary to define the procedures to implement the following elements of the language:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;semantics - the core evaluator composed of the eval-apply procedures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;syntax - procedures detailling how to write legal expressions in the language&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;environment manipulation - procedures that implement the Environment Model defined in the previous post&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;primitive procedures and initial global environment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read-eval-print loop (REPL) to interact with the evaluator&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;I close this post by including this funny clip taken from the lecture given by Prof. Gerald Sussman.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="videoblock"&gt;
&lt;div class="content"&gt;
&lt;iframe width="660" height="402" src="https://www.youtube.com/embed/Ow9AtuIuMLw?rel=0" frameborder="0" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-introductory-concepts/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-introductory-concepts/</link><title>SICP series - Introductory Concepts</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;This post is going to illustrate some of the introductory concepts presented in the book &lt;code&gt;Structure and Interpretation of Computer Programs&lt;/code&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_terminology"&gt;Terminology&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;procedure&lt;/code&gt; is a series of mechanical steps to be followed in order to deduce the value associated to a problem. It is a &lt;em&gt;recipe&lt;/em&gt; for describing the &lt;em&gt;how-to&lt;/em&gt; imperative knowledge.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;process&lt;/code&gt; is the actual sequence of steps within a computer which concerns a particular version of the problem.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A &lt;code&gt;language&lt;/code&gt; provides the tools to capture procedures and describe processes; it is composed of several components.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;vocabulary&lt;/code&gt; - basic elements of computation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;syntax&lt;/code&gt; - rules for writing compound expressions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;semantics&lt;/code&gt; - rules to deduce meaning of constructs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;procedure&lt;/code&gt; - rules for capturing process of evaluation&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;abstraction&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In order to create a language then the following ones are the steps to be taken.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;create a set of primitive elements in a language (simple data and procedures) - &lt;code&gt;primitives&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create a set of rules for combining elements of the language - &lt;code&gt;means of combination&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create a set of rules for abstracting elements of the language - &lt;code&gt;means of abstraction&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;From an implementation point of view in Scheme, the previous elements are translated into the following constructs.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;primitives: numbers, strings, booleans, built-in procedures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;means of combintation: open parenthesis, expression evaluating to a value, possibly other expressions, close parenthesis
Example: (+ 5 6 (* 2 3))&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;means of abstraction: define keyword, name, expression whose value is associated to that name
Example: (define total (- 100 30))&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The goal of writing procedures is then to control complexity; procedures lead to the fundamental concept of &lt;code&gt;abstraction&lt;/code&gt;. A procedure can then be seen as a black box, in which the details of its implementation are hidden and detached from its use. To put it all together the elements of a language allow to create complex systems through the means of combination of primitives, which can then be abstracted into procedures and then be used as primitive elements themselves. This cycle is beneficial for designing, maintaining and extending complex computational systems.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;interfaces and programming paradigms&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Abstraction allows to isolate components of a system, but it also provides the &lt;code&gt;interfaces&lt;/code&gt; to interconnect those simple components. Some conventions or programming paradigms are for example object-oriented and streams.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;meta-linguistic abstraction&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The most powerful tool a language provide when the aforementioned tools are not sufficient to solve some problems is known as &lt;code&gt;meta-linguistic abstraction&lt;/code&gt;. This consists in creating languages specifically oriented at some problem domain.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To sum up the previous points, the following outline provides an overview of the major sections which comprise the book.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;procedure and data abstraction&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;conventional interfaces and programming paradigms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;meta-linguistic abstractions&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-abstraction/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-abstraction/</link><title>SICP series - Procedural and Data Abstraction</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The purpose of this post is to provide an example on how &lt;a href="robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-procedural-abstraction/"&gt;procedural&lt;/a&gt; and &lt;a href="robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-data-abstraction/"&gt;data&lt;/a&gt; abstractions can be exploited and combined together to build modular systems. At the end of this article you should be convinced that there is actually not a clear distinction between the two types of abstractions, rather they are two sides of the same coin. I am going to outline only the most important points on the picture language defined in the book &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is possible to build domain specific languages in Scheme for describing and solving the domain problem. Since the language is embedded within Scheme, it inherits the power of Scheme. The topic of the current post is to build a language to draw pictures in the style of Escher &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt;. What we want to do is drawing into frames intricated recursive patterns out of a figure we will name George. We can proceed to define George straight away in the following manner&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (george rect)
  (draw-line rect .25 0 .35 .5)
  (draw-line rect .35 .5 .3 .6)
  (draw-line rect .3 .6 .15 .4)
  ; ...
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The problem with this implementation is that both the action of drawing George and the data representing George are intertwined. Besides, the representation of the elements of George are very low-level. With some data abstraction it is possible to define vectors as poitns in space and segments as lines connecting two vectors. So a better representation of George could be&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (george-lines)
  (list
    (make-segment p1 p2)
    (make-segment p2 p3)
    (make-segment p3 p4)
    ; ...
  )
)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here we have defined George in terms of segments, which is a higher level of abstraction. Besides, these lines are defined with respect to some coordinate frame, but they are not being drawn yet. So the act of drawing has been separated from the representation of the data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now comes the key problem: drawing a picture within a frame. The first idea that comes to mind could be to create a procedure to draw collections of segments. However, we would like to have the flexibility of using any frame to draw in. So, a picture could be made a procedure. This may sound weird at first, since one would normally assume it should be a data structure, but it is actually a good idea because it captures the procedural abstraction of drawing data within a frame. The procedure is going to contain the geometric entities of George, but is also going to take as input a frame, the nscale the elements to fit within the frame and finally display the results. This abstraction results in an increased flexibility in manipulating the picture structure. We are now going to define the function which implements this job.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define (make-picture seglist)
  (lambda (frame)
    (for-each
      (lambda (segment)
        (let ((b (start-segment segment))
              (e (end-segment segment)))
          (draw-line frame
                     (xcoord b)
                     (ycoord b)
                     (xcoord e)
                     (ycoord e))))
    seglist)))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;First of all note that &lt;code&gt;make-picture&lt;/code&gt; is a higher-order procedure, since it returns another procedure. It takes as input a list of segments to be drawn, George in our case. The inner procedure takes the frame on which to draw the figure as input, making the drawing process of the figure independent of the frame in which to draw in. The body of the inner function cycles through each segment of the list of segments (George), assigns the the start vector and end vector of the segment to two local variables, then proceeds to draw inside the segment inside the frame (note the &lt;code&gt;draw-line&lt;/code&gt; we had previously employed to define George). Finally, George can be defined with the following instruction:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define g (make-picture george-lines))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To wrap up, George is now both a data abstraction (&lt;code&gt;george-lines&lt;/code&gt;, a list of segments) and a procedure (&lt;code&gt;g&lt;/code&gt;, a procedure for drawing those lines within a frame). Also note that &lt;code&gt;g&lt;/code&gt; contains the information about the segments within it as part of the procedural abstraction. This makes it easy to use George as the building block to draw other pictures and define other operations such as scaling, rotation, combinations.&lt;/p&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.4" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-15.html#%_sec_2.2.4&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://en.wikipedia.org/wiki/M._C._Escher" class="bare"&gt;https://en.wikipedia.org/wiki/M._C._Escher&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-mutation-and-environment-model/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-mutation-and-environment-model/</link><title>SICP series - Mutation and Environment Model</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;So far in the previous posts we have dealt only with &lt;code&gt;functional programming&lt;/code&gt;. According to this model, all procedures are &lt;code&gt;pure&lt;/code&gt; functions, which means they can be conceptually treated as mathematical functions. A function in mathematics is simply a mapping from its input values to some output values; so a function is dependent only on the input parameters it is passed. Also, the function should return the same output any time it is given the same input values. In the programming world, this entails that procedures do not alter any existing data structures, or in other words they do not &lt;code&gt;mutate their state&lt;/code&gt;. In fact, any time an operation is performed on a data structure, a new copy is returned from it. For example, the operation of adding an element to the end of the list (usually implemented by the function &lt;em&gt;append&lt;/em&gt;) does not alter the given list; instead, the following steps are taken:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a copy of the list is made&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the element is added to the end of the list&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the copy of the list is returned&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This means that the list passed as input to &lt;em&gt;append&lt;/em&gt;, after being processed by this function, is unchanged, i.e. does not possess any new element. It is then possible to operate on this list assuming that nowhere throughout the course of the program it was modified. This is the reason why we say pure functions are exempt from &lt;code&gt;side effects&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The previous point, i.e. that functions limit themselves to return values rather than altering any existing data structure, shows the composability quality of functional programs. With this perspective in mind, it is possible to view programs as made of the interactions among its functions, where each function depends on the value resulting from the execution of another function; at the same time, that function can provide the input value to the next one. This model of computation is reminiscent of commands piping in Unix systems. Again, notice how the data structures in the system are left unaltered, while the functions do their computations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_mutation"&gt;Mutation&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As good as this model may be, it however poses some limitations, so today we are going to introduce the topic of &lt;code&gt;mutation&lt;/code&gt;. This concept is implemented in Scheme by mutators, which take a variable name and a value and bind that value to that name; if that variable possessed a value, this is discarded and the new value is assigned to the variable. This is done with the following instruction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(set! x "foo")&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Notice how this differs from &lt;code&gt;define&lt;/code&gt;, in that this construct creates a new binding between a name and a value. It is however not possible to redefine this binding with another &lt;code&gt;define&lt;/code&gt;; what happens is that the previous binding is discarded and a new binding is created. So &lt;code&gt;define&lt;/code&gt; can only create new bindings, not alter them. Even though apparently the outcome may be the same, it is important to appreciate the subtle difference.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The important effect mutation brings to the table is that it introduces &lt;code&gt;time&lt;/code&gt; or &lt;code&gt;context&lt;/code&gt; in our model of computation. Now, two expressions with identical syntax may be associated to different semantics as they rely on the context surrounding their evaluation. Their meaning is dependent on the time they are evaluated, which means the order in which expressions are evaluated matter. For example&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(define x 10)
(+ x 5) ; 15
; ...
(set! x 90)
; ...
(+ x 5) ; 95&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;note how in the previous excerpt the same instruction &lt;code&gt;(+ x 5)&lt;/code&gt; can result in two different values depending at the point in time where it is evaluated in the program.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_environment_model"&gt;Environment Model&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This shift in paradigm from functional to &lt;code&gt;state-based&lt;/code&gt; requires a new evaluation model to evaluate expressions by also taking into account the effects introduced by mutation. This leads also to a shift in the viewpoint on computation. According to the new vision, the following elements can be viewed in the following manner:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;variable&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OLD - name for a value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NEW - place where it is possible to store something&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;procedure&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OLD - functional description of a computational process&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NEW - object with inherited context&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;expression&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NEW - only has meaning with respect to an environment&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;These considerations bring us the the definition of what we will call the &lt;code&gt;Environment Model&lt;/code&gt; (EM). What follows now is a description of the structure of this model.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A frame consists of a table of bindings; each binding in the table is a pairing of a name and a value.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An environment consists of a nested sequence of frames, where a frame can be shared by multiple environments; the connection between two frames is called the &lt;code&gt;enclosing environment pointer&lt;/code&gt;. All the evaluation occurs within the scope of an environment, which provides the context for how symbols and names are interpreted.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The current environment changes when the interpreter applies a procedure.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The top environment is called the &lt;code&gt;global environment&lt;/code&gt; (GE); it is the starting point in a program and holds the bindings for all its basic expressions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The rule to evaluate a combination is the followign one:&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;evaluate the sub-expressions in the current environment&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apply the value of the first sub-expression to the values of others&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;What follow now are rules of evaluation of EM. To have a visual depiction of the following rules I advise to consult the slides of lesson 15 which can be found here &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name-rule&lt;/code&gt;: a name X evaluated in environment E gives the value of X in the first frame of E where X is bound&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;define-rule&lt;/code&gt;: a define construct evaluated in environment E creates or replaces a binding in the first frame of E&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;set!-rule&lt;/code&gt;: a set! of variable X evaluated in environment E changes the binding of X in the first frame of E where X is bound&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;lambda-rule&lt;/code&gt;: a lambda construct evaluated in environment E creates a procedure whose environment pointer is E&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;application&lt;/code&gt;: this consists of four steps&lt;/p&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;create a new frame A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make A into an environment E; A&amp;#8217;s enclosing environment pointer goes to the same frame as the environment pointer of the procedure being applied P&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;within A, bind the parameters of P to the argument values&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;evaluate the body of P with E as the current environment&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Again, note the difference between &lt;code&gt;set!&lt;/code&gt; and &lt;code&gt;define&lt;/code&gt;. &lt;code&gt;set!&lt;/code&gt; always finds an existing binding for the variable, walking up the chain of environment pointers until it finds a binding and changes it. &lt;code&gt;define&lt;/code&gt; always creates a binding in the same frame, even though there was a previous binding there.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Also note how the lambda-rule implements the concept commonly known in functional programming as function &lt;code&gt;closure&lt;/code&gt;. In fact, a function has access to the state of the lexical scope (frame) in which it has been defined. In other words, all the variables defined in the same scope of the function (when defined) are visible inside the function itself and can be included in its body. This means that, regardless of where in the program a function is called, the function keeps the same state of those variables even though the current lexical scope may be totally different and those variables may not exist anymore. This is because, as explained in the rule above, the procedure object has its environment pointer pointing to the frame in the environment where it was evaluated at definition time.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Finally, I conclude this post by pointing out that all rules in the EM are evaluation rule, while the last rule considers application of procedures. We will see in the next &lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-metacircular-evaluator/"&gt;post&lt;/a&gt; that the interplay between expression evaluation and function application is going to be the core of the whole evaluation process of any program.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/lecture-notes/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/lecture-notes/&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-intro/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-14-sicp-series-intro/</link><title>SICP series - Introduction</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;With this post I am going to start a series of posts concerning what I believe (and not only me) to be one of the most valuable resources on programming and more in general computer science: the mythical &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt;. The full content of the book is available online at the link &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt;; I also warmly advise to have a look at the MIT courseware which offers valuable resources which aid the understanding of the book; I recommend in particular the videos (which can be found here &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt;) as both Sussman and Abelson, the authors of the book, are phenomenal teachers. The lecture notes are also useful and can be found here &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote."&gt;3&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;My purpose with this series of posts is to illustrate the major topics of the book, but I will not cover all of them though; in particular, I will leave out the whole Chapter 5 which dives deeply low-level.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;em&gt;Small preamble before starting&lt;/em&gt;: I have to clarify that I did not read the book fully nor did I complete the exercises (I know the hacker community will hate me for this and I will be branded as poser). To actually get the most out of the book, one should complete the notoriously challenging exercises, which will your understanding to the next level. It is however particularly time consuming and requires a hell of a determination, so be prepared.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_what_is_it_about"&gt;What is it about&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;So, the reason why this book is considered an essential reading is because it does the amazing job of compacting an astonishing number of fundamental topics related to programming, software development and language design. Historically, this book used to be taught to freshmen of MIT, so to people with likely no prior experience in programming and computer science. I can imagine that a student successfully completing the exam would be well equipped for any further topic (I would personally hire him on the spot already as he knows way more than many practicioners in the industry). I believe nonetheless that if someone is experienced this book is equally valuable, as it allows the reader to go through the concepts he may have been exposed to by presenting them in a logical and coherent framework. This book may shed a new light on concepts which the reader may have not been reasoning about so much and overall will bring his understanding to the next level. Besides, the reader will finally have the opportunity to get acquainted if not even becoming well-versed with the very cool Scheme, one dialect of the revered and feared Lisp language. I affirm that fundamental concepts should be very well founded not only for the academic, but in particular for the practicioner, as he will build software which will have a reach and impact to the world and its people.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_contents"&gt;Contents&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;in this paragraph I will list the main concepts which the book covers to provide an overview of the breadth of topics it touches:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Abstraction through procedures&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Imperative vs declarative&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Functional programming (lambda function, pure functions, higher-order functions, &amp;#8230;&amp;#8203;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Iterative vs recursive algorithms&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Algorithm complexity&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Abstraction on data focusing on the pair and list as fundamental building blocks of Lisp programs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Types&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Abstract data type&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mutation of state&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The Environment Model as a framework for evaluation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fundamental data structures: tables, stack, queue, tree, graph&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object-oriented programming&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Concurrency&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interpretation for building a language using Scheme&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interpretation for building Scheme using Scheme (metacircular evaluator)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lazy evaluation and streams&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Register machines and compilation (how the evaluation model is actually implemented in the hardware)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_key_takeaways"&gt;Key takeaways&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The book is a gold mine of valuable teachings, but there are a few which I think stand out and should be remembered the most.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The fundamental building blocks constituting a language are the following: primitive elements, means of combination (syntax) and means of abstraction (semantics). Further than this, meta-linguistic abstractions provide the tools to create languages suited to any problem domain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Procedural abstraction allows to capture patterns of computation which result in a modular system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Data abstraction allows to decouple the implementation from the usage of the data structures suited to the problem. This also results in added modularity to the system.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;In Lisp, it turns out that there is not a real boundary between procedure abstraction and data abstraction, as programs are but lists of expressions. One can view a program as a tree composed of expressions expressed in the form of lists. Anything can then be defined both in terms of the procedures which implement its behavior and the data structures which implement it. I will make an article to further flesh out on this.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Lisp is a language powerful enough that it allows the programmer to define a language using the language itself. Furthermore, it allows to define the Lisp language by using the language itself (this is referred as metacirular evaluator in the book and is perhaps the most crucial point). The concept is mind-bending as well as illuminating, and I will dedicate another post to elaborate more on this.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_3"&gt;
&lt;a href="#_footnoteref_3"&gt;3&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/lecture-notes/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/lecture-notes/&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Thu, 14 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-13-fp-series-intro/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-13-fp-series-intro/</link><title>A brief overview of Haskell</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;This post will provide a brief overview of the programming language Haskell. One reason why Haskell is an apt language to study the concepts of functional programming is that unlike most, it is a pure functional language. This means that Haskell code is free from side effects and imperative structures. As we will see briefly, the language puts at disposal a framework to deal with side effects, or else it would not be of practical use in the real world. This post will touch the topics covered in the book by Hutton &lt;sup class="footnote" id="_footnote_hutton"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; and the edX MOOC &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;table of contents FP concepts series (prog lang part A and maybe B, edx fp)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;generic
functions without any side effect
recursion
list comprehensions
closures
higher-order functions
lazy eval, stream&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;statically typed
pattern matching
monads
	parsing
	IO
types
	basic types, list/tuple/function types, overloaded types, polymorphic types, currying, type declarations, data types, type classes&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dynamically typed
macros&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html" class="bare"&gt;http://www.cs.nott.ac.uk/~pszgmh/pih.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" class="bare"&gt;https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Wed, 13 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-foldr-vs-foldl/</link><title>foldr vs foldl</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;Folding is one important topic in functional programming. It is a pattern exploiting the higher-order capability to compose functions, i.e. functions can be passed other functions arguments or can return a function. This pattern is used to employ common iterative operations over lists which reduce to a single result. This is in fact the algorithm behind the common library function &lt;em&gt;reduce&lt;/em&gt; implemented in most common programming languages nowadays. There are two variants of folding depending on the direction in which the computational process unfolds, so either right or left. This gives the names of &lt;strong&gt;foldr&lt;/strong&gt; and &lt;strong&gt;foldl&lt;/strong&gt;. The examples that follow will be written in Haskell for conciseness. I advice the book by Hutton &lt;sup class="footnote" id="_footnote_hutton"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; to have an introduction to these concepts or the  edX MOOC &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; which also provides plenty of exercises to consolidate the knowledge.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_foldr" class="sect0"&gt;foldr&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;sup class="footnoteref"&gt;[&lt;a class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;foldr f v [] = v
foldr f v (x : xs) = f x (foldr f v xs)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Even though it may look daunting at first sight, it becomes very clear and intuitive once you have grasped the meaning of it. This formula is written in recursive form, so the first line expresses the base case while the second line expresses the recursive case. The left-hand side of the formula is the application of the function &lt;code&gt;foldr&lt;/code&gt; on parameters:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;, the name of the function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;v&lt;/code&gt; , the initial value&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[]&lt;/code&gt; is the empty list; the base case means that at this point of the computation there are no more elements in the list to consider&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(x : xs)&lt;/code&gt;, which is the Haskell notation to express a list composed of head (first element) &lt;code&gt;x&lt;/code&gt; and tail (all elements from second to last) &lt;code&gt;xs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now for the interesting part, the right-hand side of the formula. In the base case, the function simply returns the initial value. Easy. In the recursive case, function &lt;code&gt;f&lt;/code&gt; is applied to the first element of the list &lt;code&gt;x&lt;/code&gt;. After that, the &lt;code&gt;foldr&lt;/code&gt; function is called recursively on the remaining elements of the list.
Now it is clear that the computational process of &lt;code&gt;foldr&lt;/code&gt; has a recursive shape.
Let&amp;#8217;s make an example to illustrate what previously said.
Turns out that the common higher-order pattern &lt;code&gt;map&lt;/code&gt; can be rewritten in terms of &lt;code&gt;foldr&lt;/code&gt;: &lt;code&gt;mapR f = foldr (\ x xs &amp;#8594; f x : xs) []&lt;/code&gt;.
Here the application of function &lt;code&gt;f&lt;/code&gt; over the list is defined in terms of an anonymous function (lambda function) taking two parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;xs&lt;/code&gt;. The empty list &lt;code&gt;[]&lt;/code&gt; is  the initial value (&lt;code&gt;v&lt;/code&gt; in the formula above). &lt;code&gt;x&lt;/code&gt; represents the first item in the list starting from the end of the list, while &lt;code&gt;xs&lt;/code&gt; represents the accumulator. So the lambda function returns a list composed of the function application on element &lt;code&gt;x&lt;/code&gt; concatenated with the accumulator &lt;code&gt;xs&lt;/code&gt;. To properly understand how the computation unfolds, I find it more intuitive to reason backwards, starting from the last element moving backwards to the first; the accumulator is then compounded starting with the empty list on the right and prepending the elements of the list one by one starting from the last element. For example applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;[1,2,3]&lt;/code&gt; taking function &lt;code&gt;(*2)&lt;/code&gt; gives the list &lt;code&gt;[2,4,6]&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;map (*2) [1,2,3]
((*2) 1) : ((*2) 2) : ((*2) 3) : []
2 : 4 :  6 : [] = [2,4,6]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id="_foldl" class="sect0"&gt;foldl&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The formula used to express this pattern is the following one, written in Haskell &lt;sup class="footnoteref"&gt;[&lt;a class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; (the type signature is omitted for simplicity purposes):&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;foldl f v [] = v
foldl f v (x : xs) = foldl f (f v x) xs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This function shares many similarities with the one expressed above for &lt;code&gt;foldr&lt;/code&gt;. The difference lies in the right-hand side of the recursive case formula. &lt;code&gt;foldl&lt;/code&gt; is called recursively, and it is given the following arguments:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="ulist"&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;, the function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;(f v x)&lt;/code&gt;, is the accumulator, which is given by the application of &lt;code&gt;f&lt;/code&gt; on the previous value of the accumulator &lt;code&gt;v&lt;/code&gt; and the first element of the list &lt;code&gt;x&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;xs&lt;/code&gt;, the remaining elements of the list starting from the second one&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear that &lt;code&gt;foldl&lt;/code&gt; follows an iterative shape instead, as the algorithm starts by applying the function to the base case and the first element of the list; this is the new accumulator. Then the function is applied to the next element and the accumulator, which results in a new accumulator. This process continues until the end of the list is reached. Note that I have not said that the accumulator assumes a new value at each step, because the evaluation is done after the unwrapping of the list starting from right to left, which gives the name to the pattern.
For symmetry, I am going to express the function &lt;code&gt;map&lt;/code&gt; using &lt;code&gt;foldl&lt;/code&gt;:
&lt;code&gt;mapL f = foldl (\ xs x &amp;#8594; xs ++ [f x]) []&lt;/code&gt;.
The lambda function takes two parameters: &lt;code&gt;xs&lt;/code&gt; is the accumulator, while &lt;code&gt;x&lt;/code&gt; is the first element of the list. A list is returned, composed of the application of &lt;code&gt;f&lt;/code&gt; on &lt;code&gt;x&lt;/code&gt;, to which is prepended the accumulator &lt;code&gt;xs&lt;/code&gt;. Note that the accumulator is the initial value &lt;code&gt;[]&lt;/code&gt;. So the computation unfolds from left to right, and once the end of the list is reached, it starts folding back from right to left, hence the name. Applying &lt;code&gt;map&lt;/code&gt; on list &lt;code&gt;[1,2,3]&lt;/code&gt; taking function &lt;code&gt;(*2)&lt;/code&gt; gives the list &lt;code&gt;[2,4,6]&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;map (*2) [1,2,3]
(([] ++ [(*2) 1]) ++ [(*2) 2]) ++ [(*2) 3]
[] ++ [2] ++ [4] ++ [6] = [2,4,6]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html" class="bare"&gt;http://www.cs.nott.ac.uk/~pszgmh/pih.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0" class="bare"&gt;https://www.edx.org/course/introduction-functional-programming-delftx-fp101x-0&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-expressions-vs-statements/</link><title>Expressions vs statements</title><description>&lt;div id="preamble"&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;&lt;strong&gt;Statements&lt;/strong&gt; are standalone units of execution which do not return any value. As such, it is clear that they are used to perform side effects in a program.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_functional_vs_imperative"&gt;Functional vs imperative&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;To get an overview of the different paradigms you can refer to article &lt;a href="https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/"&gt;Programming Paradigms Explained&lt;/a&gt;.
Given the definitions above, it is clear that &lt;strong&gt;expressions&lt;/strong&gt; constitute the building blocks of the &lt;strong&gt;functional paradigm&lt;/strong&gt;, since everything should be always evaluated to give a value, and regardless of the time of invocation, given the same inputs should return same output values out of the expression. Statements, on the other hand, as said previously, are meant to provide side effects to the program, so it is clear that they can&amp;#8217;t exist in purely functional programs.
On the other hand, &lt;strong&gt;statements&lt;/strong&gt; are fundamental blocks of the &lt;strong&gt;imperative&lt;/strong&gt; style (together with expressions) as they are used to alter the control flow of the program through constructs such as conditionals, loops, procedures.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_examples"&gt;Examples&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Here follow a few examples to illustrate the differences outlined above.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_if_conditionals"&gt;If conditionals&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Some languages provide conditionals as expressions while others as statements; it is usually the case that languages that employ statements also provide an equivalent expression form (the ternary operator).
If the conditional is an &lt;strong&gt;expression&lt;/strong&gt;, it is evaluated to value, which means that it can be for example assigned to a variable or passed as a function argument; basically, it can be treated as any other value. In standard ML one can write for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;val acidity = if ph &amp;lt; 7 then "ACID" else if ph = 7 then "NEUTRAL" else "BASE"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is clear that, being an expression, the conditional is required by the language to provide a value no matter what, thus all possible cases should be considered and a value should be returned for each. In this example the else branches are not optional, because if the ph level is greater or equals to 7, there must be some other value you return.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;If the conditional is a &lt;strong&gt;statement&lt;/strong&gt;, it doesn&amp;#8217;t return a value, so for example it cannot be assigned to a variable, but it is a sort of logical block containing instructions with side effects. In Python you could write an if statement like this:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;acidity = ... # could be any value
...
if ph &amp;lt; 7:
	acidity = "ACID"
elif ph == 7:
	acidity = "NEUTRAL"
else:
	acidity = "BASE"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This snippet shows that, no matter which branch is taken, the statement mutates the value of the variable &lt;code&gt;acidity&lt;/code&gt;. Note that it would be illegal syntax to assign this block to the variable &lt;code&gt;acidity&lt;/code&gt;. Finally, the language does not enforce you to provide a value for all the possible values of &lt;code&gt;ph&lt;/code&gt;, you could in fact only define the first if branch and ignore the other cases.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_loops"&gt;Loops&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imperative languages provide different constructs to loop over series of values or data structures (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &amp;#8230;&amp;#8203;) which produce side effects. Functional languages instead do not provide a loop construct, but rely on the mechanism of recursion over data structures to implement it, since a value is returned out of it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect2"&gt;
&lt;h3 id="_languages_mixing_both_paradigms"&gt;Languages mixing both paradigms&lt;/h3&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;It is now clear how languages that mix both the functional and imperative (e.g. object-oriented) styles make you define a certain construct either as an expression or as a statement respectively. For example, in Kotlin the body of a function can be defined as:
- functional style: &lt;code&gt;fun f() = when {&amp;#8230;&amp;#8203;}&lt;/code&gt; the body is an expression and when it is evaluated to produce a value, this is assigned to the function.
- oo style:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;fun f(ch: Char) {
	ch = ch + 1
	print(ch)
	return ch
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;the body is a statement composed of a sequence of instructions producing side effects.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="sect1"&gt;
&lt;h2 id="_wrap_up"&gt;Wrap-up&lt;/h2&gt;
&lt;div class="sectionbody"&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;We have seen that while expressions are evaluated to return a value, statements do not return any value, performing instead side effects. As such, programs written in the imperative style are constituted by both expressions and statements which implement some logic altering the state of the program (e.g. conditions, looping). The functional paradigm instead mandates the exclusive usage of expressions since by definition side effects are not admitted.
The &lt;strong&gt;advantages&lt;/strong&gt; of using &lt;strong&gt;expressions over statements&lt;/strong&gt; is first of all that the program is contained from the side effects which would be introduced were you to use statements. Another advantage is that all constructs in the program are always evaluated to a value; as such, they can be passed around in the program as you would with simple values such as primitives or simple expressions. This favours composition, since the program itself is an expression made out of other expressions which produce a value. This means that the program can be passed around, returned or composed, allowing for further flexibility.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-function-closures/</link><title>Function closures</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The topic of this post is function closures. Closure refers to the context that is passed to a function when it is defined. Basically, the state of the variables that are in the lexical scope when the function is defined is captured and retained in the function. Thus, when the function is subsequently invoked, the variables referenced by the function retain the value they possessed in the lexical scope of the function when it was defined, even though the current scope may be completely different! In Javascript we could write for example:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;let x = 4;
let f = y =&amp;gt; y + x;
...
x = 7;
f(2); // this will return the value 6&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As visible from this simple example, the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope of the function &lt;code&gt;f&lt;/code&gt; at the moment of its declaration and is bound to the value &lt;code&gt;4&lt;/code&gt;. At a later point in the program the value of the variable &lt;code&gt;x&lt;/code&gt; is changed to &lt;code&gt;7&lt;/code&gt;, and the variable &lt;code&gt;x&lt;/code&gt; is in the lexical scope when the function is invoked in the last line. However, the result of the function application is &lt;code&gt;6&lt;/code&gt; instead of &lt;code&gt;9&lt;/code&gt;. The reason for this is that function &lt;code&gt;f&lt;/code&gt; had a closure over &lt;code&gt;x&lt;/code&gt; when &lt;code&gt;f&lt;/code&gt; was defined, so no matter what value &lt;code&gt;x&lt;/code&gt; may have in the future, it is still bound to &lt;code&gt;4&lt;/code&gt; any time &lt;code&gt;f&lt;/code&gt; is invoked. The same would be valid even if &lt;code&gt;x&lt;/code&gt; would not be in the current scope at the moment function &lt;code&gt;f&lt;/code&gt; is invoked.
This simple example illustrated an important feature of closures: functions can store the information present in the lexical scope where they are defined. The implications of this are huge, and many idioms and patterns have found foundation from this concept.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_currying" class="sect0"&gt;Currying&lt;/h1&gt;

&lt;h1 id="_memoization" class="sect0"&gt;Memoization&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;The memoization technique is useful when you want to cache the result of some expensive computation. It basically consists in storing a local reference inside a function to a variable defined outside the function; its value is going to be used in some expensive computation. The first time the function is invoked, you may check whether the variable is defined (you may also use a boolean flag for the purpose of checking), and since it is not, the function body is evaluated to produce the result of the computation which is going to be stored in a local variable. So, any subsequent times the function is called, the function will limit itself to return the result of the computation instead of recomputing it every time.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_library_wrapping" class="sect0"&gt;Library wrapping&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another example of pattern commonly employed in Javascript is library wrapping, also known with the name of revealing module pattern, and it is used to create a module abstraction in an environment were every element would have public visibility otherwise.&lt;/p&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-programming-paradigms-explained/</link><title>Programming paradigms explained</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The topic of this post concerns something fundamental in the matter of programming: programming paradigms. Note that, while there exist other paradigms other than the ones considered here, these will not be treated as they are out of the scope of this post.
We will first consider the two main approaches overarching all the other paradigms: imperative and declarative. I also advice to have a look at the definitions provided in the very first chapter of &lt;strong&gt;Structure and Interpretation of Computer Programs&lt;/strong&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_1" class="footnote" href="#_footnote_1" title="View footnote."&gt;1&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_2" class="footnote" href="#_footnote_2" title="View footnote."&gt;2&lt;/a&gt;]&lt;/sup&gt; for a very good explanation of the difference between the two.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_imperative" class="sect0"&gt;Imperative&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Imperative is concerned with the &lt;strong&gt;how-to&lt;/strong&gt; knowledge of an algorithm, i.e. it details the sequence of steps or instructions necessary to accomplish a certain algorithm. An analogy to visualise this could be for example the following sequence of instructions to go from point A to point B:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;move two cells to the right
move one cell to the top
move five cells to the right
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id="_declarative" class="sect0"&gt;Declarative&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Declarative deals instead with the &lt;strong&gt;what-is&lt;/strong&gt; knowledge, thus it provides a definition but does not specify the steps for a certain algorithm. This approach is more proper to mathematics, mathematical formulae are a very good example of declarative knowledge. For instance, to calculate the hypotenuse of a right triangle you could use the Pythagorean theorem &lt;code&gt;c^2 = a^2 + b^2"&lt;/code&gt;. Note that it does not give you a list of instructions of how to calculate the hypotenuse, just a definition.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_main_paradigms" class="sect0"&gt;Main paradigms&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Now we will consider the most common paradigms.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_procedural" class="sect0"&gt;Procedural&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;This is the paradigm used to indicate those programs in which the code is organised into logical units called procedures. Contrarily to functions, procedures do not return any value, but act simply as groupings of instructions. This style of programming is the first to have been employed and dates back to Fortran. The main merits of this paradigm is that of introducing modularity and scoping into programs. Note that this style is purely imperative.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_object_oriented" class="sect0"&gt;Object-oriented&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Object-oriented is perhaps the most well-known paradigm since it has been since the late '80s-'90s the de-facto standard in the industry. This style differs from the procedural in that it introduces several concepts such as class, interface, inheritance, polymorphism which add layers of abstraction to the program and model the reality with entities interacting between each others. Their interactions cause mutations in the state of the objects, which can lead to untameable complexity if not properly managed and kept under control with the proper amount of testing. A complete treaty of this paradigm is out of the scope of this post, as there are loads of good resources out there explaining exhaustively OO concepts &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_3" class="footnote" href="#_footnote_3" title="View footnote."&gt;3&lt;/a&gt;]&lt;/sup&gt; &lt;sup class="footnote"&gt;[&lt;a id="_footnoteref_4" class="footnote" href="#_footnote_4" title="View footnote."&gt;4&lt;/a&gt;]&lt;/sup&gt;. This style of programming is imperative.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_functional" class="sect0"&gt;Functional&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;According to this paradigm, programs should be composed of pure functions and immutable data structures. Pure functions are functions which do not cause any side effect, i.e. they do not change the state of the program. Immutable data structures indicate that any data structure in the program is not mutated; in order to perform computations on these structures, copies are made and acted on. Another characteristic of the functional style is that functions are first-class citizens, i.e. they can be treated as any other value, thus assigned to variables, passed around in functions either as arguments or return values, etc. This makes the program more declarative since you define the specification of a computational process through pure functions and their composition instead of defining the sequence of instructions which implements the required computational process.
Note that for real applications a purely functional approach by itself is pretty much useless, as the program would just act as a box computing things but without any connection with the outer world. For this reason, even pure functional languages such as Haskell provide mechanisms to deal with state mutation or side effects. This comes to the cost of losing the declarative quality typical of functional programs.
An example of this in Haskell is the &lt;code&gt;do&lt;/code&gt; block for monads, useful to deal with side effects:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;do
	putStrLn "hello"
	putStrLn "world"&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Another example is the &lt;code&gt;begin&lt;/code&gt; block in Scheme or Racket to express sequences of instructions:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;(begin
  (printf "hello")
  (+ 1 2))&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="footnotes"&gt;
&lt;hr&gt;
&lt;div class="footnote" id="_footnote_1"&gt;
&lt;a href="#_footnoteref_1"&gt;1&lt;/a&gt;. &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html" class="bare"&gt;https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-10.html&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_2"&gt;
&lt;a href="#_footnoteref_2"&gt;2&lt;/a&gt;. &lt;a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/" class="bare"&gt;https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/1a-overview-and-introduction-to-lisp/&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_3"&gt;
&lt;a href="#_footnoteref_3"&gt;3&lt;/a&gt;. &lt;a href="https://www.goodreads.com/book/show/4845.Code_Complete" class="bare"&gt;https://www.goodreads.com/book/show/4845.Code_Complete&lt;/a&gt;
&lt;/div&gt;
&lt;div class="footnote" id="_footnote_4"&gt;
&lt;a href="#_footnoteref_4"&gt;4&lt;/a&gt;. &lt;a href="http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html" class="bare"&gt;http://propella.sakura.ne.jp/earlyHistoryST/EarlyHistoryST.html&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item><item><guid>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</guid><link>https://robywan27.github.io/my-blog/posts/2019-11-11-static-vs-dynamic-type-checking/</link><title>Static vs dynamic type checking</title><description>&lt;div class="paragraph"&gt;
&lt;p&gt;The type system is one of the fundamental elements which make up a programming language. There are two main categories under which most languages fall into: static and dynamic type checking. This taxonomy is orthogonal to that of programming paradigms such as object-oriented and functional.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_static_type_checking" class="sect0"&gt;Static type checking&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;A strong type checking system mandates that every value in the program belong to one supported type in the program. If the compiler cannot infer the type of any given value, it will throw an error. For this reason, it is possible for statically-typed languages to detect type errors at compile time, which provides benefits later when the program is run. The fact that the program passes the compilation phase does not imply that the program is correct though, as there may be other kinds of errors in it. An interesting topic related to static type checking is type inference, which is employed by SML and its derived languages (link to article about type inference and Hindley-Milner).&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_dynamic_type_checking" class="sect0"&gt;Dynamic type checking&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Dynamically-typed languages skip the type checking phase and the program is executed straight away. It is usually the case that languages employing this type checking are not compiled but rather interpreted, such as Ruby, Javascript, Python, Scheme (the reality can be more complex than written here, but a detailed treaty is out of scope).  This means that the class of errors which may have likely been detected with static type checking will go undetected until the running program incurs in them and crashes or even worse it executes wrongly. Although dynamically-typed languages give up program safety, they gain in flexibility; in fact, they allow the programmer to define heterogeneous data structures and abstractions which would otherwise be clumsy if not possible in a statically-typed language. For example, it is possible in Scheme to define lists of any element regardless of the type. A valid list can be &lt;code&gt;(1 "2" #t)&lt;/code&gt;. This is not possible in Haskell for example, where each element of a list must conform to the specified type of the list:&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;multiplyByTwo :: [Int] -&amp;gt; [Int]
multiplyByTwo xs = map (*2) xs&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;which when executed at the command line gives&lt;/p&gt;
&lt;/div&gt;
&lt;div class="listingblock"&gt;
&lt;div class="content"&gt;
&lt;pre class="highlight"&gt;&lt;code&gt;&amp;gt; multiplyByTwo [1, 2, 3, 4]
[2, 4, 6, 8]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;One misconception to be beware of is that dynamic type does not mean that values do not have types, they are indeed typed, just their type is inferred while the program is running rather than by the compiler.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_strong_vs_weak_type" class="sect0"&gt;Strong vs weak type&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;An honourable mention is worth giving to the strong vs weak type classification, since it is often wrongly used interchangeably instead of static and dynamic type checking. Actually, there is not a definitive definition of strong and weak type. Most languages, even dynamically-typed ones, are strongly typed. Weakly-typed languages are those languages which perform some kind of implicit type conversion. C and C++ are the most well-known languages which can be defined weakly-typed.&lt;/p&gt;
&lt;/div&gt;
&lt;h1 id="_overview_of_some_popular_languages" class="sect0"&gt;Overview of some popular languages&lt;/h1&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;As a closing point I will provide an overview of some popular languages in relation to their type system and programming paradigm.
The following table provides a rough classification of some popular languages:&lt;/p&gt;
&lt;/div&gt;
&lt;table class="tableblock frame-topbot grid-all" style="width: 90%;"&gt;
&lt;caption class="title"&gt;Table 1. Classification of some popular programming languages wrt type checking and paradigm&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col style="width: 33.3333%;"&gt;
&lt;col style="width: 33.3333%;"&gt;
&lt;col style="width: 33.3334%;"&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class="tableblock halign-right valign-top"&gt;&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;dynamically-typed&lt;/th&gt;
&lt;th class="tableblock halign-left valign-top"&gt;statically-typed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-right valign-top"&gt;&lt;p class="tableblock"&gt;&lt;strong&gt;object-oriented&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Ruby&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Java, C++&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class="tableblock halign-right valign-top"&gt;&lt;p class="tableblock"&gt;&lt;strong&gt;functional&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;Scheme, Clojure, Elixir&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;td class="tableblock halign-left valign-top"&gt;&lt;p class="tableblock"&gt;&lt;em&gt;SML, Haskell&lt;/em&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="paragraph"&gt;
&lt;p&gt;Note that it is usually not entirely correct that a language follows exclusively one single paradigm as most popular languages are multi-paradigm. Nonetheless there is usually one paradigm which is primary to a given language. Some other languages position in the middle and allow both styles interchangeably, such as Scala and Kotlin. Some languages have not been included as their classification would be ambiguous. Python is weakly-typed and supports both paradigms, even though it is more apt to either a procedural or object-oriented style. Javascript is weakly-typed and draws a lot from the functional approach, even though it does support some kind of object-oriented form.&lt;/p&gt;
&lt;/div&gt;</description><pubDate>Mon, 11 Nov 2019 00:00:00 +0100</pubDate></item></channel></rss>